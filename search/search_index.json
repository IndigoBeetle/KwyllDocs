{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Kwyll","text":""},{"location":"#what-is-kwyll","title":"What is Kwyll?","text":"<p>If you're new to Kwyll, a quick introduction to what it is, why it is, and how it came about would probably be useful, so here goes.</p> <p>Kwyll is, at it's core, a tool for creating retro-styled games for retro platforms. What is \"retro\"? Well, in terms of Kwyll, it will initially include anything that existed at the start of the home computer revolution, so primarily 8-bit platforms, very low power, simple capabilities, such as the Sinclair ZX Spectrum, Commodore 64, Amstrad CPC, etc. It may extend beyond that in time, but that's the primary target. In its current form, Kwyll only targets the Sinclair ZX Spectrum (my personal favourite machine from the era).</p> <p>That covers what it is, why it is, well that's a longer story, but I'll try to keep it as short as I can. I've been involved with computers and software development since I was 14 years old (1983!), and my first, well actually second, my first was a ZX81, computer was a Sinclair ZX Spectrum, the 16K version which I later upgraded to 48K myself when I got the upgrade as a Christmas present from my parents. I've spent a good portion of my career working in games, starting on the 8-bit platforms of the time at Incentive Software. As such, these platforms hold a great deal of nostalgia for me, memories of a time I've always been very fond of. Fast forward to recent times, after a career working in the software industry, with some very complex systems including visual effects, VR, modern video games systems, FinTech etc. I found myself drawn back to the early days, when things were simpler and more fun, well, that's how I remember it anyway. A new wave of respect for retro tech. in all shapes and forms seems to be taking hold, which only added fuel to my desire to revisit those times. Then along comes the \"Spectrum Next\" project on Kickstarter. Unfortunately, I missed the first round, but definitely got in on the second. In anticipation of it's arrival, I determined I was going to be making some games like the good old days. I bought an Agon Light, a cheap Z80 based open source system that had gained some popularity just about the right time, and set to remembering how to program in Z80 again. While this was fun, I soon realised that this was not what I wanted to do, I guess I'd become too spoiled by modern tools and technologies. So, I decided the best way to do what I wanted to do was to make a tool to do it. I'd already gained some experience with this, being responsible for the 3D Construction Kit at Incentive, and having worked on in-house tools at various games companies in my career, I knew this was something I could do and enjoy doing. And so Kwyll was born, as with all the best projects, a means of scratching my own itch, that garnered some interest from the community and grew into something else.</p>"},{"location":"nav/","title":"Nav","text":"<ul> <li>Welcome</li> <li>Introduction</li> <li>Interface</li> <li>Logic</li> <li>Tutorials</li> </ul>"},{"location":"interface/assets_panel/","title":"Assets Panel","text":""},{"location":"interface/data_editor/","title":"Data Editor","text":""},{"location":"interface/kwyll_interface/","title":"The Kwyll Interface","text":"<p>Figure 1. Main Interface</p> <p>The main interface of Kwyll consists of a single window with a menu, toolbar, a tabbed main area and status bar. The menu is not shown in Main Interface, it is an operating system menu and as such on macOS displays at the top of the screen as per operating system guidelines, on Windows and Linux it may show at the top of the window above the toolbar.</p>"},{"location":"interface/kwyll_interface/#toolbar","title":"Toolbar","text":"<p>The toolbar contains shortcuts to commonly used functionality provided by the  menu functions, in order from left to right:</p>  New Game Clear the current game and start a new empty game.  Save Game Save the current game.  Load Game Load an existing game, replacing the currently open one.  Export Game Export the current game and build for running on a device or emulator.  Review Export Display a breakdown of the exported project for review, showing important   information such as how much memory is used by different parts of the game.  Undo Undo the last action taken. Kwyll keeps a list of all actions taken up to   the current point, allowing you to step back in history to undo changes made   or redo them. Once any number of undo steps are taken and a new change is made   the changes that could be redone are cleared and it no longer becomes possible   to redo from that point.  Redo Redo the last action undone.   Settings Edit game settings.   Settings Show information about the version and satus of your Kwyll installation."},{"location":"interface/kwyll_interface/#tabbed-area","title":"Tabbed Area","text":"<p>The main body of the Kwyll window is taken up by the tabbed area. Each editor that Kwyll has is in a separate tab in this area, including Screen, Data, Sprites, Objects, Rooms, Map, Sound, Logic and Preview.</p>"},{"location":"interface/kwyll_interface/#status-bar","title":"Status Bar","text":"<p>The status bar at the very bottom of the window is used to provide information about the game to the designer such as memory use.</p> <p></p> Memory Use Shows how much memory, in bytes, the game data currently uses out of how much   is available for use. If the usage exceeds the available space, the game will not work   on device or emulator."},{"location":"interface/logic_editor/","title":"Logic Editor","text":""},{"location":"interface/logic_editor/#editing-nodes","title":"Editing Nodes","text":"<p>Nodes are created by right clicking the mouse in an empty area of the grid or pressing Shift+A, a pop-up menu will appear with a list of all the possible Node types as a tree organised by category. The popup has, in addition to the list of nodes, a text entry field that will be focused by default, typing in here will filter the nodes list to only those that contain the typed text, this is a very efficient way to find the exact node you're looking for. As you type in the search field, the list will instantly adapt to show only the matching nodes, and the first in the list will be selected. You can add the selected node by pressing return, or use the Up and Down arrow keys to move among the nodes that match the search term to select before pressing return. As you become familiar with the available nodes, this will be the most efficient way to add nodes to the logic graph. Initially it may be better to use the mouse to scroll through the list and click on the node you require directly. Below the list of nodes is a small text field that will change to show a short description of the currently selected node.</p> <p>When a node is added to the graph, it will appear at the current mouse position.</p> <p>Click and drag on Nodes to move them around the graph and organise your program. You can Ctrl/Cmd click on multiple Nodes to select more than one at a time, or click and drag in space on the grid to drag a rectangle around a selection of Nodes.</p> <p> To connect Ports left click on one of the two Ports and drag, a wire will appear connected to the Port you clicked on and the mouse. Drag the mouse to the other Port and when you get close enough, it will snap to the Port, release the mouse to complete the connection. If you struggle to begin the connection operation because the port is too small, it can sometimes be helpful to zoom in, this can be achieved using the mouse wheel or pinch gesture. Ports can be connected in either direction, it makes no difference to the way they work, data only flows from output to input.</p> <p>To disconnect a port, click on the input end of the wire, the end going into the input port of a Node, drag it away from the port and it'll disconnect, you can reconnect to another port while still holding the mouse, or release the mouse with the wire disconnected to delete the wire altogether.</p>"},{"location":"interface/map_editor/","title":"Map Editor","text":""},{"location":"interface/nav/","title":"Nav","text":"<ul> <li>The Kwyll Interface</li> <li>Screen Editor</li> <li>Data Editor</li> <li>Sprite Editor</li> <li>Object Editor</li> <li>Room Editor</li> <li>Map Editor</li> <li>Sound Editor</li> <li>Logic Editor</li> <li>Preview</li> <li>Assets Panel</li> <li>Tilemap Editor</li> </ul>"},{"location":"interface/object_editor/","title":"Object Editor","text":""},{"location":"interface/preview/","title":"Preview","text":""},{"location":"interface/room_editor/","title":"Room Editor","text":""},{"location":"interface/screen_editor/","title":"Screen Editor","text":"<p>The Screen Editor is where in Kwyll you get to create and modify Screens. It is organised into four main areas, the Screens List, the Instruments List, the  Assets Panel and the Main Area.</p>"},{"location":"interface/screen_editor/#the-screens-list","title":"The Screens List","text":"<p>This is where you can select, add and remove the various screens that you have in your game. The local toolbar below the list includes buttons to create a new screen, delete the currently selected screen, and duplicate the currently selected screen, to the left side. It also has a button to edit the screen properties to the right. </p> <p></p>"},{"location":"interface/screen_editor/#screen-properties","title":"Screen Properties","text":"<p>The Screen Properties dialog is shown when double clicking a screen in the screens list, or clicking the screen properties button. This is where you can  modify various properties of the currently selected screen that are not editable in the main area layout and logic tabs.</p> Name The name of the screen. This is used in logic for example when selecting to    switch to a different screen, the Switch Screen   node will list the screen names in a dropdown control to make it easy to select   which screen to switch to. Game Screen? This toggles whether the screen should contain the game window or not. Typically   only one screen in your game will have the game window included, but it is    possible to have it in multiple screens, even in different places on the screen.   Some screens, such as a menu screen, a help screen, etc. will not require the   game window to be shown, they will consist entirely of instruments. Start Screen? This toggles if the screen should be the initial screen visible when starting    your game. Only one screen can have this flag set, so selecting it here will   automatically clear it on all other screens. The start screen is also shown in    the Screens List with a flag icon. Ink, Paper and Bright These combined set the default colours for the current screen. Instruments   can override these values. The paper colour is used as the background to the   entire screen. These values are also used as the default colours for tiles in   the screen tilemap unless replaced by painting attributes in the tilemap, or by   assigning colours to tiles. <p></p>"},{"location":"interface/screen_editor/#the-instruments-list","title":"The Instruments List","text":"<p>This is where you can select, add and remove the various Instruments defined in the currently selected screen. The local toolbar below the list includes buttons to create a new instrument and delete the currently selected instrument, to the left side. It also has a button to edit the instrument properties to the right. </p> <p></p> <p></p> <p>The Instrument Properties dialog is shown when double clicking on an instrument or clicking the instrument properties button. This is where you can modify the various  properties of an instrument.</p> Name The name of the instrument. This is used in logic for example when selecting to    update an instrument value, the Set Instrument   node will list the instrument names in a dropdown control to make it easy to select   which instrument to update. Position: This is the position on the screen for the top left corner of the instrument.    Instruments are placed on a grid of cells, each 8x8 pixels in size, so on the    Spectrum, the range of these values are 0 to 31 in X and 0 to 23 in Y, any values   beyond this range will result in the instrument being at least partially off screen. Size The size in cells of the instrument, as with the position, the instrument size is   specified in terms of cells, each 8x8 pixels in size. Type The type of the instrument. An instrument will display its Value in    different ways depending on the type of instrument. A text instrument will display   a string from the strings list, an integer instrument will display a numerical    value, and a tile instrument will show a single tile from the tileset. Value The initial value of the instrument, the meaning of the value depends on the   instrument type. Color These controls allow you to override the default colour information defined by the   screen. Ink and paper can be specified separately or ignored, choosing the black    colour with an \"X\" indicates that the instrument should not change the default for    ink or colour and instead use the value specified in the screen. The brightness value    can on or off, only if one of ink or paper is specified. <p></p>"},{"location":"interface/screen_editor/#assets-panel","title":"Assets Panel","text":"<p>The Assets Panel provides access to assets that can be placed in the screen editor view in addition to Instruments. It is a common element used in more than one editor in Kwyll, and as such has its ow separate  section of the documentation here. </p> <p></p>"},{"location":"interface/screen_editor/#main-area","title":"Main Area","text":"<p>The rest of the Screen Editor is taken up with the main area, where the majority of the editing of a Screen takes place. It consists of two tabs, Layout and Logic. The Logic tab is a standard Logic Editor component that is used to edit logic that applies to the current room, see Logic for more details.</p> <p>The Layout tab contains the screen layout editing tools. It consists of two parts, a  standard Tilemap Editor component, and layered on top of it a specific set of editing features for Screens. The Tilemap Editor is documented  separately as a common component.</p>"},{"location":"interface/screen_editor/#layout","title":"Layout","text":"<p>The screen Layout Editor works as a set of additional tools that operate in the same space as the Tilemap Editor. It provides visual tools for interactively placing screen elements such as Instruments and the Game Window.</p> <p>An Instrument is represented on the  grid as a yellow rectangle with a small triangle in the bottom right corner . You can click and drag the instrument on the grid, it will automatically conform to the grid cells, snapping to 8x8 increments. By carefully clicking on the small triangle in the corner, you can drag out the rectangle to change its size, again, it will automatically conform to  the grid.</p> <p>If the screen being edited has the Game Screen flag set in the properties, a blue rectangle will show to represent the Game Window. This element does not have a resize handle (triangle), as it's not possible to resize the game window in a screen, the game window size is fixed on all screens, the only way to modify the game window size is in the Settings dialog. However, the game window can be positioned independently on each screen it is used, so dragging the blue rectangle representing the game window works in much the same way as an Instrument, it will also conform to the grid as appropriate. </p> <p></p>"},{"location":"interface/sound_editor/","title":"Sound Editor","text":""},{"location":"interface/sprite_editor/","title":"Sprite Editor","text":""},{"location":"interface/tilemap_editor/","title":"Tilemap Editor","text":""},{"location":"introduction/terminology/","title":"Terminology","text":"<p>There are several stages to developing a game with Kwyll, each with their own section in the tool. Below is a short introduction to some of the terminology that you will come across frequently throughout this documentation, this is a good place to start to ensure that you have the best chance of understanding what is being described later in the guide.</p>"},{"location":"introduction/terminology/#sprites","title":"Sprites","text":"<p>Of course, any game needs some graphics, right? In Kwyll there are two main places you can draw pixel graphics, Sprites, and Tiles. A Sprite in Kwyll is a rectangular grid of pixels, Sprites can be various sizes, always in increments of 8 pixels in both axes. So, for example, 8x8, 16x16, 8x16, etc. An arbitrary limit is placed on the maximum size of 32 in either axis just to keep things within reason for the target platforms to maintain performance and limit memory use. </p> <p>It is important to know that a Sprite doesn't actually 'do' anything in Kwyll, it's just an image, it has no position, it isn't by default drawn to the screen anywhere, in order to get a Sprite onto the screen, it must be used by an Object.</p>"},{"location":"introduction/terminology/#objects","title":"Objects","text":"<p>An Object in Kwyll is a type of thing that can be displayed on screen and respond in various ways to the input of the player or to game logic that is defined in Kwyll. Objects are the heart of any Kwyll game, without Objects, the game wouldn't actually do anything, making for a very dull game. </p> <p>An Object must first be defined, the definition of an Object details things like the visual represenation via Sprites and any other information that is required to display the object that may be platform specific, such as colour and draw mode, and any Logic. </p> <p>However, an Object Definition does not contribute to the game iself, it has to be used. Objects can be used in Rooms and the Map, each use shares the visual representation and logic code from the Object Definition, but each use  has its own position, values for the variables defined in the logic, Timeline Animations, and any other information that might be specific to a particular platform. Objects can be used in the following ways.</p> <ul> <li>Map Objects - these are created in the Map    Editor and are constant throughout the game,    they will always exist irrespective of which Location you are    in, and will be drawn, if their position puts them on screen, and their logic    will be run.</li> <li>Room Objects - these are in each Room Definition and will only be    active while in a Location that uses that Room, so they will    not be drawn or their logic run when in location that uses another room.    It's worth noting that when exiting a room that contains Room Objects, the    data used by the Kwyll library for those objects, such as memory for    Sprite etc. will be freed, reducing the overhead for    both memory and performance, so it is advisable to use Room Objects where    appropriate over Map Objects.</li> <li>Dynamic Objects - these are not created in an editor during your game    creation, they are instead created during the game using the Spawn    Object node, and can be destroyed using the    Kill Object node. They are in all other    respects similar to Global Objects, they are not constrained to a particular    Room, and will continue to exist across changes in    Location until they are destroyed.</li> </ul> <p>An Object Definition consists of two main elements.</p> <ul> <li>Animations, which are sequences of Sprite images played in order    to create the illusion of animation. Each object can have many Animations,    for example, a player object might have an animation for walking left, one    for walking right, one for jumping, one for attacking etc. The game designer    can choose which Animation is played using the logic nodes based on what is    happening in the game at that moment.</li> <li>Logic is the \"brains\" of an Object, it defines what an Object does,    and when. In Kwyll, logic is created using a visual programming tool, a    powerful means of writing code without writing code.</li> </ul>"},{"location":"introduction/terminology/#tiles","title":"Tiles","text":"<p>Tiles are the simpler, more constrained, cousin to Sprites. They are also simple grid of pixels, however, a Tile is always 8x8 (unless a particular platform supports or requires a different size), and cannot be used in Objects, instead they are used in Rooms, typically to draw the background of a room, over which an Object's Sprites are drawn, and Screens, typically to draw borders or background graphics for a screen be it a menu screen, a game screen or any other use, and also as the content of an Instrument of the appropriate type.</p>"},{"location":"introduction/terminology/#tilemap","title":"Tilemap","text":""},{"location":"introduction/terminology/#rooms","title":"Rooms","text":"<p>A game in Kwyll consists of a number of Rooms, each room represents a separate space in the game, Kwyll does not currently support scrolling so gameplay is constrained to a single screen at a time, rooms allow you to move between these spaces. Each Room contains any combination of the following elements:</p> <ul> <li>A Tilemap, which represents the background of the room, such as the scenery,    walls, platforms, etc.</li> <li>Room Objects, which are unique to that room definition and are    only active while the room is active.</li> <li>Room Logic that is specific to the room defintion. Logic triggers    on a Room only run when a Location that uses the Room is the    current game location.</li> <li>Markers, very lightweight objects that only contain position information, no    sprites or logic, and are used primarily within Room or Object    Logic to place things within a room dynamically, for example, a    marker may be used as a spawn point for the player, or as a position to    appear when entering a room from another room.</li> </ul> <p>A Room Defintion, much like an Object Definition doesn't actually contribute to the game itself until it is used, in the case of a Room, the definition has to be used in the Map in a Location. The Map can contain multiple Locations that use the same Room Definition, much like an Object Definition can be used multiple times for Room and Map objects.</p>"},{"location":"introduction/terminology/#screens","title":"Screens","text":"<p>A Screen in Kwyll is a collection of Instruments, a Tilemap, and optionally, the game window. A screen can also have Logic associated with it that is run while that screen is the current screen. </p> <p>There is only one screen active at any time in a Kwyll game. Uses of screens include the main game screen which will have the game window positioned on the screen accordingly, a menu screen, instructions, and many others.</p>"},{"location":"introduction/terminology/#instruments","title":"Instruments","text":""},{"location":"introduction/terminology/#logic","title":"Logic","text":""},{"location":"introduction/terminology/#timeline-animation","title":"Timeline Animation","text":""},{"location":"introduction/terminology/#locations","title":"Locations","text":""},{"location":"introduction/terminology/#data","title":"Data","text":""},{"location":"logic/intro/","title":"What is Logic in Kwyll?","text":"<p>One of the most important aspects of a game created with Kwyll is the ability to make objects, and other things, \"do stuff\", this is achieved with the logic system that is built into Kwyll. It is akin to the programming language in other game creation tools, but instead of being text based, it is visual, working by wiring together small items that do a relatively simple thing so that the whole does something more interesting. </p> <p>These \"small items\" are called Nodes, Kwyll provides a basic set of Nodes that can be combined to do a variety of things, the process of \"wiring\" them together enables each Node to either pass data to another node, or to control the flow of the \"program\". Some of the Nodes are very simple, such as the Math Node, whose only job is to take in two values, perform a basic mathematical operation on them, add, subtract, multiply or divide, and then output the result. Others are more complex and perform a detailed operation in and of themselves based on the input and parameters.</p> <p>Each node has an optional set of input and output Ports which can be of different types depending on their purpose, and a set of Parameters which configure the operation of the Node.</p> <p> This  is a relatively simple Node that demonstrates most of the key features of a logic Node. Here you can see on the left of the Node; 3 input Ports, one with a double arrow at the top, and two green ones below. The double arrow port is a Flow port, it is connected to other ports of the same type to control the flow of execution. A Node will only have at most 1 Flow input port. The green ports are data inputs, they provide integer numerical values to the node from some other node. You'll notice that the \"B\" Port also has a numerical input field alongside it, this is a parameter, in this particular case the value that the Node uses can either be provided by another node via the Port or specified as a fixed value in the parameter. In this example, you may want to compare the input from another Node at A with either an input from another Node or with a specific fixed value, 0 in this case. If you connect another Node to the input Port B, the numerical input field will be hidden as it is no longer necessary. On the right of the Node are the output ports, in this example there are two Flow Ports, True and False. This Node is a \"branching\" node, it will perform a comparison of the two values A and B using the specified comparison type, for example \"equal\". If the comparison results in a true result, i.e. the two values are equal, the flow will follow whatever is connected to the True output Port, if anything. If the comparison is false, A and B are not equal, the flow will follow the False output Port. Below the B port is another Parameter, in this case it is the type of comparison to be made between A and B, equal, greater than, less than, etc. This Parameter has no input port, so it can only have a fixed value chosen at deisgn time. It is a means of configuring the operation of a Node in a way that doesn't require input from another Node. To summarise, on this Node A is a Port only, it requires an input wire to work, B is an input Port or Parameter you can choose how this value is set depeneding upon your needs, and the comparison type is a Parameter, you must choose this value when editing and it cannot change at runtime.</p> <p> Some nodes will have no Flow ports at all, this means the Node is not meant to be part of the flow, but instead is meant to provide data to other nodes that are part of the flow. These Nodes will have output data Ports that can be connected to the input data Ports of other Nodes, when a Node that is part of a flow has a wire connecting one of its input Ports to the output Port of another Node, it will request the value from the other Node when it needs it.</p> <p>Nodes that are in a logic graph but not connected to a valid Flow or have output Ports that are not connected to anything, will not contribute to the program and will not be exported.</p> <p>There are several types of data that can be passed between logic nodes in Kwyll,  each with a unique colour for the port and wires that connect them.</p> Number Shown as green, a signed 16 bit integer value,    capable of representing anything between -32768 and 32767. Object Shown as blue, a reference to an object in the    game, can be a Room object or a global object. Location Shown as magenta, a reference to a location    on the map."},{"location":"logic/intro/#editing-nodes","title":"Editing Nodes","text":"<p>See the Logic Editor for a detailed explanation of the tools for creating and editing logic graphs in Kwyll.</p>"},{"location":"logic/process_order/","title":"Logic Order of Processing","text":"<pre><code>graph TD \n    A[Start Game/Reset Game] --&gt; G1;\n    subgraph G1[Global];\n        B([Initialise]);\n    end;\n    G1 --&gt; S;\n    subgraph S[For Each Screen];\n        SA([Initialise]);\n    end;\n    S --&gt; R;\n    subgraph R[For Each Room];\n        direction LR;\n        RA([Initialise]) --&gt; RO;\n        subgraph RO[For Each Room Object];\n            RB([Initialise]);\n        end;\n    end;\n    R --&gt; G2;\n    subgraph G2[For Each Global Object];\n        C([Initialise]);\n    end;\n    G2 --&gt; FR;\n    subgraph FR[Each Frame];\n        subgraph G3[Global];\n            E([Always]);\n        end;\n        subgraph CS[Current Screen];\n            F([Always]);\n        end;\n        subgraph CR[Current Room];\n            G([Always]);\n            subgraph RO2[For Each Room Object];\n                H([Always]);\n            end;\n            G --&gt; RO2;\n        end;\n        subgraph GO[For Each Global Object];\n            J([Always]);\n        end;\n        G3 --&gt; CS;\n        CS --&gt; CR;\n        CR --&gt; GO;\n    end;</code></pre>"},{"location":"logic/nodes/always/","title":"Always","text":""},{"location":"logic/nodes/always/#description","title":"Description","text":"<p> The Always Node is a specific type of Node called a Trigger. A trigger Node is an entrypoint into a flow in the Kwyll logic. The Always trigger is the most commonly used trigger node, it will run the flow that follows on from it's Flow Out port every frame of the game.  </p> <p></p>"},{"location":"logic/nodes/always/#ports","title":"Ports","text":"Flow Out As with all trigger nodes, an Always Node has only a single flow port   on the output side. There is no input flow to a trigger node as it is   the origin of a flow."},{"location":"logic/nodes/always/#parameters","title":"Parameters","text":"Order Always Nodes have a single additional parameter, order. This is   used to define the order in which multiple Always Nodes in a single   logic program will be processed, in case there is some dependency   between flows. If there are multiple Always Nodes with the same order,   they will be processed together in an arbitrary order."},{"location":"logic/nodes/and/","title":"And","text":""},{"location":"logic/nodes/and/#description","title":"Description","text":"<p> The And Node takes two inputs of type integer and compares them with 0. If both are not 0, the output will be 1, if either or both are 0, the output will be 0. </p> <p>This is useful to combine checks, in particular with the Integer Compare node.</p> <p></p>"},{"location":"logic/nodes/and/#ports","title":"Ports","text":"A and B The two input values, they must be linked for the node to be operational and   can only be connected to sources that provide an integer value, such as   Get. Out The output of the node, will be either 1 or 0 depending on the result of   the compare."},{"location":"logic/nodes/anim_event/","title":"AnimEvent","text":"<p> The AnimEvent Node is a specific type of Node called a Trigger. A trigger Node is an entrypoint into a flow in the Kwyll logic. The AnimEvent trigger is connected to the timeline animation feature in the Rooms Editor. It will run the flow that follows on from it's Flow Out port when a the current timeline animation for this object hits a keyframe that has the Trigger Event checkbox selected. The Frame and T output ports provide the frame number of the keyframe in the timeline, and the T value specified in the editor respectively.</p> <p></p>"},{"location":"logic/nodes/anim_event/#ports","title":"Ports","text":"Flow Out As with all trigger nodes, an Animation Event Node has only a single flow   port on the output side. There is no input flow to a trigger node as it is the   origin of a flow. Frame An integer output port that provides the frame number of the triggering   keyframe in the timeline. T An integer output port that provides the T value set in the timeline editor,   in the range 0-127."},{"location":"logic/nodes/beep_fx/","title":"Beep FX","text":""},{"location":"logic/nodes/beep_fx/#description","title":"Description","text":"<p> The Beep FX Node is used to play a beeper sound effect defined in the Beep FX panel of the Sound Editor. </p> <p></p>"},{"location":"logic/nodes/beep_fx/#ports","title":"Ports","text":"Flow In In order for this node to perform its operation, it must be connected into an   active flow using this input port. The flow will ultimately originate at a   Trigger node but can come from the Flow Out port of any other flow   node. Flow Out A node connected to the Flow Out port will be executed in sequence   following the completion of this node's operation. FX An integer input port used to provide the index of the Beep FX sound effect in   the list as defined by the Sound Editor."},{"location":"logic/nodes/beep_fx/#parameters","title":"Parameters","text":"FX A dropdown selection of existing sound effects from the Beep FX tab of the   Sound Editor. Use this if you wish to   trigger a specific sound effect, use the port at the same level in the node if   you wish to trigger a sound effect based on some calculations elsewhere in the   logic graph."},{"location":"logic/nodes/change_location/","title":"Change Location","text":""},{"location":"logic/nodes/change_location/#description","title":"Description","text":"<p> The Change Location Node is used to switch to another Location on the map. The location to change to will be wither the numerical index of the location on the map, you can find this by looking at the Map Editor and noting the number of the location displayed in the top left corner, or the location name if chosed from the provided dropdown.</p> <p>The Change Location node is only reqiured to switch to a new location if not using Auto Navigate, or in combination with Auto Navigate to transport to a new location that isn't  adjacent on the map, such as a hidden room or interior space for example.</p> <p></p>"},{"location":"logic/nodes/change_location/#ports","title":"Ports","text":"Flow In In order for this node to perform its operation, it must be connected into an   active flow using this input port. The flow will ultimately originate at a   Trigger node but can come from the Flow Out port of any other flow   node. Flow Out A node connected to the Flow Out port will be executed in sequence   following the completion of this node's operation. Location An integer input port used to provide the index of the map location as defined   in the Map Editor."},{"location":"logic/nodes/change_location/#parameters","title":"Parameters","text":"Location A dropdown selection of existing location names from the Map   Editor. Use this if you wish to change to a   specific location, use the port at the same level in the node if you wish to   use a location index based on some calculations elsewhere in the logic graph."},{"location":"logic/nodes/clamp/","title":"Clamp","text":""},{"location":"logic/nodes/clamp/#description","title":"Description","text":"<p> The Clamp Node takes an integer value on the In port, if the value is less than or equal to the Min port/parameter the Min port/parameter value is output, if it is greater than or equal to the Max port/parameter the Max port/parameter value is output, otherwise the value is output unmodified. </p> <p></p>"},{"location":"logic/nodes/clamp/#ports","title":"Ports","text":"In An integer input port used to provide the input value for testing. This must be   connected for the node to operate correctly. Out An integer output port, the result of the comparison detailed in the   description is output on this port. Min An integer input port, using this allows you to specify the minimum value from   elsewhere in the logic graph, such as via an Number node. Max An integer input port, using this allows you to specify the maximum value from   elsewhere in the logic graph, such as via an Number node."},{"location":"logic/nodes/clamp/#parameters","title":"Parameters","text":"Min A constant integer value for the minimum, used when the Min port is not   connected. Max A constant integer value for the maximum, used when the Max port is not   connected."},{"location":"logic/nodes/comment/","title":"Comment","text":""},{"location":"logic/nodes/comment/#description","title":"Description","text":"<p> The Comment Node is a non-operational node, it doesn't connect to any flow or have any input or output ports or parameters. It has a single multi-line text field that you can enter any text into. The text will be saved with the game data, but typically has no bearing on the exported data. This node is usually used to provide some useful information in more complex logic graphs, a description of the operation of a certain part of the graph, or instructions on how to use a subgraph etc.</p> <p>It is resizable and will retain its size, allowing you to place it and size it to your requirements.</p> <p></p>"},{"location":"logic/nodes/compare/","title":"Compare","text":""},{"location":"logic/nodes/controller/","title":"Controller Input","text":""},{"location":"logic/nodes/controller/#description","title":"Description","text":"<p> The Controller Input Node reports on the status of the configured controller for left, right, up, down and jump/fire. This node will adapt to whatever has been configured for the input method in your game, joystick, keyboard etc. The node allows you to define which values to return when each input is activated, defaulting to 1 for each, so that you can define the appropriate values for your needs. For example, it might be common to use -1 for left and 1 for right, to be used directly later in the graph as directions on the X axis to avoid having to convert the input to a direction manually.</p> <p>The controller reports the status in one of four modes, Pressed, Released, Just Pressed and Just Released. The Pressed and Released modes will report continuously while the input is in the appropriate state, either pressed or not pressed. The Just Pressed and Just Released will report only for the frame after the input changes to the appropriate state, pressed or released. For example, Just Pressed will report only once when the player presses the key or joystick control, commonly used for fire actions, it will not report again until the player releases that input and then activates it again.</p> <p></p>"},{"location":"logic/nodes/controller/#ports","title":"Ports","text":"Left An integer output port that will report the result of checking the state of the   left controller input based on the mode. Right An integer output port that will report the result of checking the state of the   right controller input based on the mode. Up An integer output port that will report the result of checking the state of the   up controller input based on the mode. Down An integer output port that will report the result of checking the state of the   down controller input based on the mode. Jump/Fire An integer output port that will report the result of checking the state of the   jump/fire controller input based on the mode."},{"location":"logic/nodes/controller/#parameters","title":"Parameters","text":"Left A constant integer value that will be output on the Left port if the input   check matches the mode for the left input. Right A constant integer value that will be output on the Right port if the input   check matches the mode for the right input. Up A constant integer value that will be output on the Up port if the input   check matches the mode for the up input. Down A constant integer value that will be output on the Down port if the input  check matches the mode for the down input. Jump/Fire A constant integer value that will be output on the Jump/Fire port if the   input check matches the mode for the jump/fire input. Mode Define the mode of operation between Pressed, Released, Just Pressed and   Just Released. See the description of the node operation for an explanation   of the difference between the modes."},{"location":"logic/nodes/current_location/","title":"Current Location","text":""},{"location":"logic/nodes/direction/","title":"Direction","text":""},{"location":"logic/nodes/direction/#description","title":"Description","text":"<p> The Direction Node is used to convert the typical four directional movement input into a single value representing the primary direction of movement. This is useful for things like switching sprite animation on Objects to show the correct animation for the movement. If the input suggests a diagonal movement, the output will be a single value representing the \"dominant\" axis as defined by the Vertical Priority parameter, if this is checked, then up/down will be chosen over left/right if diagonal movement is indicated, if it is not checked, left/right will get priority.</p> <p>Note: unlike other nodes with port/parameter pairs, in this node the direction rows are not port or parameter, both are required. The port is the input, usually from a Controller node, while the parameter represents the output value that will be used if that direction is determined to be the dominant direction. In the example here, if only the right controller is non-0, the Direction value output will be 2.</p> <p></p>"},{"location":"logic/nodes/direction/#ports","title":"Ports","text":"Left An integer input port providing the input value for the left direction, any   non-0 value will be considered movement in that direction.  Right An integer input port providing the input value for the right direction, any   non-0 value will be considered movement in that direction. Up An integer input port providing the input value for the up direction, any   non-0 value will be considered movement in that direction. Down An integer input port providing the input value for the down direction, any   non-0 value will be considered movement in that direction. Direction An integer output port, one of the four direction parameter values will be   output on this port depending on the input data and the Vertical Priority   parameter."},{"location":"logic/nodes/direction/#parameters","title":"Parameters","text":"Vertical Priority A boolean value indicating which axis to give priority to if diagonal   movement is indicated. If checked, up/down will get priority, otherwise   left/right will. Left A constant integer value that will be output on the Output port if the    inputs indicate movement left. Right A constant integer value that will be output on the Output port if the    inputs indicate movement right. Up A constant integer value that will be output on the Output port if the    inputs indicate movement up. Down A constant integer value that will be output on the Output port if the    inputs indicate movement down."},{"location":"logic/nodes/get_global_object/","title":"Get Global Object","text":""},{"location":"logic/nodes/get_global_object/#description","title":"Description","text":"<p> The Get Global Object Node is used to get an Object Reference to a global object for use further down the graph in other nodes that accept a Ref input. This allows you to directly affect global objects, moving them, etc.</p> <p></p>"},{"location":"logic/nodes/get_global_object/#ports","title":"Ports","text":"Ref An Object Ref output port that will provide the reference to the requested   global object."},{"location":"logic/nodes/get_global_object/#parameters","title":"Parameters","text":"Object A dropdown selector that will list all the currently available global objects.   The value selected will dictate which Ref is returned."},{"location":"logic/nodes/get_room_object/","title":"Get Room Object","text":""},{"location":"logic/nodes/get_room_object/#description","title":"Description","text":"<p>  The Get Room Object Node is used to get an Object  Reference to an object in a room for  use further down the graph in other nodes that accept a Ref input. This  allows you to directly affect room objects, moving them, etc.</p> <p></p>"},{"location":"logic/nodes/get_room_object/#ports","title":"Ports","text":"Ref An Object Ref output port that will provide the reference to the requested   global object."},{"location":"logic/nodes/get_room_object/#parameters","title":"Parameters","text":"Room A dropdown selector that will list all the currently available rooms.   When a room is selected, the contents of the Object selector will update   to list the object references in that room. Object A dropdown selector that will list all the currently available objects in the   selected room. The value selected will dictate which Ref is returned."},{"location":"logic/nodes/get_tile_information/","title":"Get Tile Information","text":""},{"location":"logic/nodes/get_variable/","title":"Get Variable","text":""},{"location":"logic/nodes/get_variable/#description","title":"Description","text":"<p> The Get Variable Node is used to get the integer value of a variable on whatever the current logic graph is running, i.e. a Screen, a Room or an Object.</p> <p>It's important to understand that, in the case of rooms and objects the value being accessed is the value for the chosen variable in the Object Reference or Location, that is running the logic code, each reference has it's own copy of the variables, they are independent.</p> <p></p>"},{"location":"logic/nodes/get_variable/#ports","title":"Ports","text":"Output An integer output port that will provide the value of the chosen variable."},{"location":"logic/nodes/get_variable/#parameters","title":"Parameters","text":"Variable A dropdown listing the defined variables associated with the current logic graph."},{"location":"logic/nodes/global_variable/","title":"Global Variable","text":""},{"location":"logic/nodes/global_variable/#description","title":"Description","text":"<p> The Global Variable Node is used to get the integer value of a variable on the global Logic.</p> <p></p>"},{"location":"logic/nodes/global_variable/#ports","title":"Ports","text":"Output An integer output port that will provide the value of the chosen variable."},{"location":"logic/nodes/global_variable/#parameters","title":"Parameters","text":"Variable A dropdown listing the defined variables associated with the global logic graph."},{"location":"logic/nodes/if/","title":"If","text":""},{"location":"logic/nodes/increment/","title":"Increment","text":""},{"location":"logic/nodes/increment/#description","title":"Description","text":"<p> The Increment Node is a simple way to modify the value of a variable on the current logic graph in one operation, avoiding the need for a Get, Math and Set sequence.</p> <p></p>"},{"location":"logic/nodes/increment/#ports","title":"Ports","text":"Flow In In order for this node to perform its operation, it must be connected into an   active flow using this input port. The flow will ultimately originate at a   Trigger node but can come from the Flow Out port of any other flow   node. Flow Out A node connected to the Flow Out port will be executed in sequence   following the completion of this node's operation. By An integer input port used to provide the amount that the variable will be    changed by, this can be positive or negative."},{"location":"logic/nodes/increment/#parameters","title":"Parameters","text":"By A constant integer amount that the variable will be changed by, used when the    By port is not connected. Variable A dropdown listing the defined variables associated with the current logic graph."},{"location":"logic/nodes/initialise/","title":"Initialise","text":""},{"location":"logic/nodes/initialise/#description","title":"Description","text":"<p> The Initialise Node is a specific type of Node called a Trigger. A trigger Node is an entrypoint into a flow in the Kwyll logic. The Initialise trigger will run the flow that follows on from it's Flow Out port only once at the start of the game.</p> <p></p>"},{"location":"logic/nodes/initialise/#ports","title":"Ports","text":"Flow Out As with all trigger nodes, an Initialse Node has only a single flow port   on the output side. There is no input flow to a trigger node as it is   the origin of a flow."},{"location":"logic/nodes/instance_data/","title":"Instance Data","text":""},{"location":"logic/nodes/instance_data/#description","title":"Description","text":"<p> The Instance Data Node provides useful information about the current Object Reference that the logic graph is running on. This is information that is unique to each reference of the object type, much like variables, but for accessing common data that all object references have.</p> <p>Note: the position data is returned in the appropriate coordinate system for the object being referenced. A global or dynamic object will return coordinates in \"map\" space, a room object will return coordinates in the local space of the room.</p> <p></p>"},{"location":"logic/nodes/instance_data/#ports","title":"Ports","text":"Ref An Object Reference input port that can provide an object that will be used   to lookup the instance data. If this is not connected and the logic is on   an Object, the current object   will be used instead. If the logic is not on an object, 0 will be returned   on all output ports. Start X The initial X position of the object, this is constant, and used to reset the    object's position at the start of the game. Start Y The initial Y position of the object, this is constant, and used to reset the    object's position at the start of the game. X The current X position of the object, this is the live position of the object   as set by any Move Object nodes, or other nodes that can   modify an object's position.  Y The current Y position of the object, this is the live position of the object   as set by any Move Object nodes, or other nodes that can   modify an object's position."},{"location":"logic/nodes/is_on_screen/","title":"Is On Screen?","text":""},{"location":"logic/nodes/is_type/","title":"Is Type?","text":""},{"location":"logic/nodes/kill_object/","title":"Kill Object","text":""},{"location":"logic/nodes/loop_while/","title":"Loop While","text":""},{"location":"logic/nodes/map_to_room/","title":"Map To Room","text":""},{"location":"logic/nodes/math/","title":"Math","text":""},{"location":"logic/nodes/message_room/","title":"Message Room","text":""},{"location":"logic/nodes/modify_tiles/","title":"Modify Tiles","text":""},{"location":"logic/nodes/move_object/","title":"Move Object","text":""},{"location":"logic/nodes/move_object_with_collision/","title":"Move With Collision","text":""},{"location":"logic/nodes/number/","title":"Number","text":""},{"location":"logic/nodes/object_hit/","title":"Object Hit","text":"<p> The Object Hit Node is a specific type of Node called a Trigger. A trigger Node is an entrypoint into a flow in the Kwyll logic. The Object Hit trigger is triggered automatically when any object that is configured to detect intersections with other objects is moved into a position where it intersects another that is also flagged to detect intersections with other  objects. Any defined Object Hit flows on both objects involved in the  intersection will be triggered.</p> <p></p>"},{"location":"logic/nodes/object_hit/#ports","title":"Ports","text":"Flow Out As with all trigger nodes, an Animation Event Node has only a single flow   port on the output side. There is no input flow to a trigger node as it is the   origin of a flow. Ref An object reference output port that provides a reference to the other object   involved in the intersection."},{"location":"logic/nodes/object_variable/","title":"Object Variable","text":""},{"location":"logic/nodes/on_message/","title":"On Message","text":""},{"location":"logic/nodes/on_message/#description","title":"Description","text":"<p> The On Message Node is a specific type of Node called a Trigger. A trigger Node is an entrypoint into a flow in the Kwyll logic. The On Message trigger is triggered manually within another flow by using the Message Room, Message Object, Message Screen or Message Global nodes.  </p> <p>A message consists of 3 parts, an ID and two optional parameters. The send message nodes have ports and parameters to set these values which control how this flow responds. The ID sent must match the ID defined in this flow for the flow to run. The parameters are typically used to control what the flow does. For example, a flow on a room that opens a door might take the side of the room that the door is on in P1 and the type of door in P2.</p> <p>The text field at the bottom of this node can be used to give a name to this message flow, it is used for informational purposes only, as a reminder to the designer of what this flow is responsible for.</p> <p></p>"},{"location":"logic/nodes/on_message/#ports","title":"Ports","text":"Flow Out As with all trigger nodes, an On Message Node has only a single flow port   on the output side. There is no input flow to a trigger node as it is   the origin of a flow. This flow is only followed if the ID of the message sent    matches the ID of this flow. P1 The value of the first parameter sent with the message, the Message nodes   have ports and parameters to define this, so each use of the message flow    can have different results based on the information passed in. P2 The value of the second parameter sent with the message, the Message nodes   have ports and parameters to define this, so each use of the message flow    can have different results based on the information passed in."},{"location":"logic/nodes/on_message/#parameters","title":"Parameters","text":"ID On Message Nodes have a single additional parameter, __ID. This is the    message ID that the flow will respond to. It is sent as part of the Message   send nodes. Using this ID it is possible to have multiple flows on an object,   room, screen or in the global logic that respond to different messages,   multiple \"functions\" if you will."},{"location":"logic/nodes/or/","title":"Or","text":""},{"location":"logic/nodes/or/#description","title":"Description","text":"<p> The Or Node takes two inputs of type integer and compares them with 0. If either or both are not 0, the output will be 1, if both are 0, the output will be 0. </p> <p>This is useful to combine checks, in particular with the Compare node.</p>"},{"location":"logic/nodes/or/#ports","title":"Ports","text":""},{"location":"logic/nodes/or/#a-and-b","title":"A and B","text":"<p>The two input values, they must be linked for the node to be operational and can only be connected to sources that provide an integer value, such as Get.</p>"},{"location":"logic/nodes/or/#out","title":"Out","text":"<p>The output of the node, will be either 1 or 0 depending on the result of the compare.</p>"},{"location":"logic/nodes/paste_brush/","title":"Paste Brush","text":""},{"location":"logic/nodes/pixel_to_tile/","title":"Pixel To Tile","text":""},{"location":"logic/nodes/random/","title":"Random","text":""},{"location":"logic/nodes/repeat/","title":"Repeat","text":""},{"location":"logic/nodes/repeat/#description","title":"Description","text":"<p>  The Repeat Node will run the node flow that is connected to its Body output port  repeatedly while an index is between the Start and Until values provided, altering  the index value each time around the loop by the Step value.</p> <p>The index is first set to the Start value, and then it is compared to the Until  value, if the Step is positive and the index is greater than or equal to the Until  value, the loop exits, similarly, if Step is negative and the index is less than or  equal to the Until value, the loop exits. That is, the loop runs while the index is  before the Until value, it is \"exclusive\".</p> <p>During the looping, the current value of the index can be accessed by nodes in the Body  using the Index port. Before execution, the index port is undefined, after execution  it will contain the last value of the index before exiting the loop.</p> <p>When the loop is complete, the logic graph will continue with the flow connected to the  Exit port.</p> <p></p>"},{"location":"logic/nodes/repeat/#ports","title":"Ports","text":"Flow In In order for this node to perform its operation, it must be connected into an   active flow using this input port. The flow will ultimately originate at a   Trigger node but can come from the Flow Out port of any other flow   node. Body The nodes that are to be repeatedly executed during the loop. Execution will    continue while there is a node connected to the Flow Out of the last node   executed, the body ends when there is no connection to the Flow Out, at which   point the index is updated and the node will check if it is to run the loop    again or exit. Start An integer port providing the start value of the index, this will be the value   of the index during the first run of the Body, it is \"inclusive\". Until An integer port providing the value to check the index against for exiting the   loop. The loop is exited before the index reaches this value. Step An integer port providing the value to add to the index each iteration through   the loop. This value can be positive or negative, allowing loops where the index   increases or decreases with each iteration. Index An integer output port that provides the current value of the index in the loop,    typically used by nodes within the Body flow. Exit A node connected to the Flow Out port will be executed in sequence   following the completion of this node's operation."},{"location":"logic/nodes/repeat/#parameters","title":"Parameters","text":"Start An integer input to specify a fixed value for the start of the loop index. Until An integer input to specify a fixed value for the exit point of the loop. Step An integer input to specify a fixed value to be added to the index each iteration   through the loop."},{"location":"logic/nodes/reset_game/","title":"Reset Game","text":""},{"location":"logic/nodes/room_entered/","title":"Room Entered","text":""},{"location":"logic/nodes/room_entered/#description","title":"Description","text":"<p> The Room Entered Node is a specific type of Node called a Trigger. A trigger Node is an entrypoint into a flow in the Kwyll logic. The Room Entered trigger will run the flow that follows on from it's Flow Out port upon entering a location that uses the room definition that this logic flow is defined on.  </p> <p></p>"},{"location":"logic/nodes/room_entered/#ports","title":"Ports","text":"Flow Out As with all trigger nodes, an Room Entered Node has only a single flow port   on the output side. There is no input flow to a trigger node as it is   the origin of a flow."},{"location":"logic/nodes/room_exited/","title":"Room Exited","text":""},{"location":"logic/nodes/room_exited/#description","title":"Description","text":"<p> The Room Exited Node is a specific type of Node called a Trigger. A trigger Node is an entrypoint into a flow in the Kwyll logic. The Room Entered trigger will run the flow that follows on from it's Flow Out port upon exiting a location that uses the room definition that this logic flow is defined on.  </p> <p></p>"},{"location":"logic/nodes/room_exited/#ports","title":"Ports","text":"Flow Out As with all trigger nodes, an Room Entered Node has only a single flow port   on the output side. There is no input flow to a trigger node as it is   the origin of a flow."},{"location":"logic/nodes/room_to_map/","title":"Room To Map","text":""},{"location":"logic/nodes/select/","title":"Select","text":""},{"location":"logic/nodes/separate_colours/","title":"Separate Colours","text":""},{"location":"logic/nodes/set_global_variable/","title":"Set Global Variable","text":""},{"location":"logic/nodes/set_instrument/","title":"Set Instrument","text":""},{"location":"logic/nodes/set_object_variable/","title":"Set Object Variable","text":""},{"location":"logic/nodes/set_variable/","title":"Set Variable","text":""},{"location":"logic/nodes/set_variable/#description","title":"Description","text":"<p> The Set Variable Node is used to set the integer value of a variable on whatever the current logic graph is running, i.e. a Screen, a Room or an Object.</p> <p>It's important to understand that, in the case of rooms and objects the value being modified is the value for the chosen variable in the Object Reference or Location, that is running the logic code, each reference has it's own version of the variables, so changing a variable on one reference for a particular object type will not affect the value on other references, they are independent.</p> <p></p>"},{"location":"logic/nodes/set_variable/#ports","title":"Ports","text":"Flow In In order for this node to perform its operation, it must be connected into an   active flow using this input port. The flow will ultimately originate at a   Trigger node but can come from the Flow Out port of any other flow   node. Flow Out A node connected to the Flow Out port will be executed in sequence   following the completion of this node's operation. Value An integer input port used to provide the value that will be applied to the   chosen variable."},{"location":"logic/nodes/set_variable/#parameters","title":"Parameters","text":"Value A constant integer value to assign to the chosen variable. If the port is    connected to another node, this option will become unavailable, the node   will use the value provided on the input port. Variable A dropdown listing the defined variable names on the current logic graph."},{"location":"logic/nodes/spawn_object/","title":"Spawn Object","text":""},{"location":"logic/nodes/sprite_animation/","title":"Sprite Anim.","text":""},{"location":"logic/nodes/store_value/","title":"Store Value","text":""},{"location":"logic/nodes/subgraph/","title":"Subgraphs","text":""},{"location":"logic/nodes/switch_screen/","title":"Switch Screen","text":""},{"location":"logic/nodes/tile_to_pixel/","title":"Tile To Pixel","text":""},{"location":"logic/nodes/timeline_animation/","title":"Timeline Anim.","text":""},{"location":"logic/nodes/transport_object/","title":"Transport Object","text":""},{"location":"logic/nodes/transport_to_marker/","title":"Transport To Marker","text":""},{"location":"logic/nodes/z80_out/","title":"Z80 Out","text":""},{"location":"tutorials/simple_platformer_controller/","title":"Simple Platformer Controller","text":""},{"location":"tutorials/simple_platformer_controller/#how-to-create-a-simple-left-right-and-jump-platformer-controller","title":"How To Create A Simple, Left, Right and Jump Platformer Controller","text":"<p>One of the most common game genres for retro computers is the platformer, a game where the player typically has controls to move left and right, and to jump onto platforms and fall down when walking off a platform. This tutorial guides you through creating the logic nodes to create a player object in this style. While this very likely won't be adequate for a fully fledged game it should give some insights into some of the techniques that Kwyll offers to do this and serve as a starting point for customisation and improvement.</p>"},{"location":"tutorials/simple_platformer_controller/#setup","title":"Setup","text":""},{"location":"tutorials/simple_platformer_controller/#sprite","title":"Sprite","text":"<p>First, lets start by creating a sprite for our character, something simple as we're not focused on animation for this tutorial.</p> <p></p>"},{"location":"tutorials/simple_platformer_controller/#object","title":"Object","text":"<p>Then we'll turn this sprite into a simple object, our Player, remember to name it appropriately and set the draw mode to mask if you've drawn a mask for your player sprite. Add a single animation with one frame and choose the sprite you created for your character.</p> <p></p>"},{"location":"tutorials/simple_platformer_controller/#room","title":"Room","text":"<p>Next we'll setup a simple room to test out the player. Create a single simple tile, in the properties dialog, make sure to set the default collision to \"top\" as this will be the tile for our platforms, we want to be able to jump up through it, but then land on the top and not fall through.</p> <p></p> <p>Draw a ground and some platforms for our player to jump on using the tile we just created.</p> <p></p> <p>Drag the Player object from the objects panel onto the room. Note: normally the player would be a \"Map\" object, which allows it to travel between rooms, but for the purposes of this tutorial, we'll just have a single room, so we can just place our player in the room directly. </p> <p></p>"},{"location":"tutorials/simple_platformer_controller/#map","title":"Map","text":"<p>Finally, in order to be able to play the game, we must add the room to the map.</p> <p></p>"},{"location":"tutorials/simple_platformer_controller/#logic","title":"Logic","text":"<p>Now that we've got all the pieces in place, it's time to look at the core of this tutorial, the logic. In order to keep things clear, the different steps of the logic are implemented as separate flows, some of them could potentially be combined if you wanted to reduce the number of nodes, that is left as an exercise for the reader. </p> <p>We break the logic down into 5 steps, movement, jump triggering, fall processing and landing.</p> <p>Firstly, we'll need some variables to use during the logic, add the following variables to the Player object logic:</p> <ul> <li>speed</li> <li>can_jump</li> <li>y_velocity</li> <li>jump_strength</li> </ul> <p></p>"},{"location":"tutorials/simple_platformer_controller/#movement","title":"Movement","text":"<p>This flow is triggered by an \"Always\" trigger so will run every frame. It serves two purposes, checking the left right keys and altering the player's position in the horizontal direction, and applying any jump/fall amounts to adjust the player's position in the vertical direction. Once this is done, it will attempt to move the player to the new location.</p> <p></p> <p>Following the flow connections (white) you can see the first thing that happens after the flow is triggered is to set the \"can_jump\" variable to 0, this is so that should the move cause the player to fall off a platform they won't be able to jump, if the move does not cause the player to start falling, this flag will be reset by the Landing flow described below.</p> <p>The next thing in the flow is the actual move, this gets the X and Y position to move to from a set of calculations. Let's look at X first. </p> <p>The \"Controller Input\" node is configured to return -1 for left and 1 for right, if either button is not pressed, it will return 0 for that direction. These two values are added together in a \"Math\" node, this is to cancel out should the player press both left and right simultaneously, as 1 + -1 is 0, if only one button is pressed, the result will be either -1 or 1 depending on whether left or right is pressed.</p> <p>The result of this calculation is then fed into another \"Math\" node that multiplies the direction by the \"speed\" variable. The result of this calculation is then fed into a third \"Math\" node that adds it to the current X position of the player, moving it in the correct direction by the desired speed.</p> <p>The Y position is calculated by adding the \"y_velocity\" variable to the current Y position of the player.</p> <p>Finally, we try to move the player to the calculated new position.</p>"},{"location":"tutorials/simple_platformer_controller/#jump-triggering","title":"Jump Triggering","text":"<p>Next, in a separate \"Always\" flow, we check the jump button, note the \"Controller Input\" is set to \"Just Pressed\" for this, as we don't want the jump to be continuous as we do for the left/right movement, this is one good reason to keep the flows separate. </p> <p></p> <p>We get the result from the \"Controller Input\" to see if jump has just been pressed. We also get the value of the \"can_jump\" variable, and feed the result of both of these into an \"AND\" node. Only if the button is pressed, and the player can jump (both are 1), do we proceed to make the player jump. This is done by simply setting the \"y_velocity\" variable to minus the \"jump_strength\" variable, remember, negative in the Y direction is UP. We also set the \"can_jump\" to 0, this prevents the player from jumping again until they have landed.</p>"},{"location":"tutorials/simple_platformer_controller/#fall-processing","title":"Fall Processing","text":"<p>Next, in yet another \"Always\" flow, we continuously adjust the \"y_velocity\" to account for gravity. We clamp the value to always be between minus the \"jump_strength\" and 10, this ensures the player never goes up by more than the defined jump strength, and never falls faster than 10 pixels per frame.</p> <p></p>"},{"location":"tutorials/simple_platformer_controller/#landing","title":"Landing","text":"<p>Finally for now, we have the logic flow that reacts when the player has collided with something. The \"Collided\" trigger is automatically run when the \"Move Object\" node in the Movement flow results in the player hitting something. For the purposes of this tutorial, we know it can only be a platform or the ground, but we check the direction for completeness anyway and to ensure that collision in other directions is cleanly handled as you continue to develop your game around this controller.</p> <p></p> <p>The flow first checks if the sides includes \"TOP\" which is 2, it does this by logically ANDing the sides value with 2. Recall that the sides is a bit field, bit 0 (value 1 if collided) is UP, i.e. the move resulting in the object hitting something from below, bit 1 (value 2 if collided) is DOWN, bit 2 (value 4 if collided) is LEFT and bit 3 (value 8 if collided) is RIGHT. The actual valud of sides is a potential combination of these values, for example, if the object collided in both the DOWN and LEFT directions, the value will be 2 + 4 = 6, ANDing with 2, will remove any other directions from the value but the DOWN value, so if the player does collide both DOWN and LEFT, LEFT will be ignored, the output from 6 AND 2 is 2, as illustrated by the binary representation below. </p> <pre><code>            RLDU\n6       00000110\n2       00000010\n</code></pre> <p>Only if both \"bits\" in the binary number are 1, will the bit be 1 in the result, so the result of ANDing these two number will be 00000010 in binary, which is 2. This means we can just compare the result with 2 to check if the object collided in a downwards direction at all, irrespective of whether it collided in another direction as well or not.</p> <p>If this is true, we set \"can_jump\" variable to 1 to indicate that the player can now jump again as they have landed.</p>"},{"location":"tutorials/simple_platformer_controller/#testing","title":"Testing","text":"<p>Back in the Room Editor, open the object properties dialog for the player and make sure the \"Collide Bg\" flag is set so that the player object will collide with our platform tiles. </p> <p>In the Variables section of the object properties, you'll need to set the values of \"speed\" and \"jump_strength\" to suitable values, 1 and 7 will be good for our example, but you can tweak those as you choose.</p> <p></p> <p>That should be all that is required to get a basic platformer control working in Kwyll. Switch to the Preview tab and start the game, you should be able to move left and right, and jump up onto the platforms. When you walk off a platform the player should fall to the ground.</p> <p> </p>"}]}