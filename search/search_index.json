{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Kwyll","text":""},{"location":"#what-is-kwyll","title":"What is Kwyll?","text":"<p>If you're new to Kwyll, a quick introduction to what it is, why it is, and how it came about would probably be useful, so here goes.</p> <p>Kwyll is, at it's core, a tool for creating retro-styled games for retro platforms. What is \"retro\"? Well, in terms of Kwyll, it will initially include anything that existed at the start of the home computer revolution, so primarily 8-bit platforms, very low power, simple capabilities, such as the Sinclair ZX Spectrum, Commodore 64, Amstrad CPC, etc. It may extend beyond that in time, but that's the primary target. In its current form, Kwyll only targets the Sinclair ZX Spectrum (my personal favourite machine from the era).</p> <p>That covers what it is, why it is, well that's a longer story, but I'll try to keep it as short as I can. I've been involved with computers and software development since I was 14 years old (1983!), and my first, well actually second, my first was a ZX81, computer was a Sinclair ZX Spectrum, the 16K version which I later upgraded to 48K myself when I got the upgrade as a Christmas present from my parents. I've spent a good portion of my career working in games, starting on the 8-bit platforms of the time at Incentive Software. As such, these platforms hold a great deal of nostalgia for me, memories of a time I've always been very fond of. Fast forward to recent times, after a career working in the software industry, with some very complex systems including visual effects, VR, modern video games systems, FinTech etc. I found myself drawn back to the early days, when things were simpler and more fun, well, that's how I remember it anyway. A new wave of respect for retro tech. in all shapes and forms seems to be taking hold, which only added fuel to my desire to revisit those times. Then along comes the \"Spectrum Next\" project on Kickstarter. Unfortunately, I missed the first round, but definitely got in on the second. In anticipation of it's arrival, I determined I was going to be making some games like the good old days. I bought an Agon Light, a cheap Z80 based open source system that had gained some popularity just about the right time, and set to remembering how to program in Z80 again. While this was fun, I soon realised that this was not what I wanted to do, I guess I'd become too spoiled by modern tools and technologies. So, I decided the best way to do what I wanted to do was to make a tool to do it. I'd already gained some experience with this, being responsible for the 3D Construction Kit at Incentive, and having worked on in-house tools at various games companies in my career, I knew this was something I could do and enjoy doing. And so Kwyll was born, as with all the best projects, a means of scratching my own itch, that garnered some interest from the community and grew into something else.</p>"},{"location":"introduction/intro/","title":"Introduction","text":"<p>Kwyll is very much a 2D game development tool, and while every effort is made to ensure that it remains flexible enought to adapt to a variety of game styles, it will always have some limitations, typically imposed by the target platforms. </p>"},{"location":"introduction/terminology/","title":"Terminology","text":"<p>There are several stages to developing a game with Kwyll, each with their own section in the tool. Below is a short introduction to some of the terminology that you will come across frequently throughout this documentation, this is a good place to start to ensure that you have the best chance of understanding what is being described later in the guide.</p>"},{"location":"introduction/terminology/#sprites","title":"Sprites","text":"<p>Of course, any game needs some graphics, right? In Kwyll there are two main places you can draw pixel graphics, Sprites, and Tiles. A Sprite in Kwyll is a rectangular grid of pixels, Sprites can be various sizes, always in increments of 8 pixels in both axes. So, for example, 8x8, 16x16, 8x16, etc. An arbitrary limit is placed on the maximum size of 32 in either axis just to keep things within reason for the target platforms to maintain performance and limit memory use. </p> <p>It is important to know that a Sprite doesn't actually \"do\" anything in Kwyll, it's just an image, it has no position, it isn't by default drawn to the screen anywhere, in order to get a Sprite onto the screen, it must be used by an Object.</p>"},{"location":"introduction/terminology/#objects","title":"Objects","text":"<p>An Object in Kwyll is a type of thing that can be displayed on screen and respond in various ways to the input of the player or to game logic that is defined in Kwyll. Objects are the heart of any Kwyll game, without Objects, the game wouldn't actually do anything, making for a very dull game.</p> <p>An Object consists of two main elements.</p> <ul> <li>Animations, which are sequences of Sprite images played in order to    create the illusion of animation. Each object can have many    Animations, for example, a player object might have an animation for    walking left, one for walking right, one for jumping, one for    attacking etc. The game designer can choose which Animation is played    using the logic nodes based on what is happening in the game at that    moment.</li> <li>Logic is the \"brains\" of an Object, it defines what an Object does,    and when. In Kwyll, logic is created using a visual programming tool    that we'll get into later, a powerful means of writing code without    writing code.</li> </ul>"},{"location":"introduction/terminology/#tiles","title":"Tiles","text":"<p>Tiles are the simpler, more constrained, cousin to Sprites. They are also simple grid of pixels, however, a Tile is always 8x8, and cannot be used in Objects, instead they are used in Rooms, typically to draw the background of a room, over which an Object's Sprites are drawn.</p> <p>Unlike Sprites, Tiles do not have their own separate editor in Kwyll, the tools to create, edit and modify Tiles are integrated into the Room editor, as they are simple and this is the only place they can be used. This choice means it's very efficient to work with Tiles when drawing your Rooms, with all the tools you need in one place.</p>"},{"location":"logic/intro/","title":"What is Logic in Kwyll?","text":"<p>One of the most important aspects of a game created with Kwyll is the ability to make objects, and other things, \"do stuff\", this is achieved with the logic system that is built into Kwyll. It is akin to the programming language in other game creation tools, but instead of being text based, it is visual, working by wiring together small items that do a relatively simple thing so that the whole does something more interesting. </p> <p>These \"small items\" are called Nodes, Kwyll provides a basic set of Nodes that can be combined to do a variety of things, the process of \"wiring\" them together enables each Node to either pass data to another node, or to control the flow of the \"program\". Some of the Nodes are very simple, such as the Math Node, whose only job is to take in two values, perform a basic mathematical operation on them, add, subtract, multiply or divide, and then output the result. Others are more complex and perform a detailed operation in and of themselves based on the input and parameters.</p> <p>Each node as an optional set of input and output Ports which can be of different types depending on their purpose, and a set of Parameters which configure the operation of the Node.</p> <p> This is a relatively simple Node that demonstrates most of the key features of a logic Node. Here you can see on the left of the Node; 3 input Ports, one with a double arrow at the top, and two green ones below. The double arrow port is a Flow port, it is connected to other ports of the same type to control the flow of execution. A Node will only have at most 1 Flow input ports. The green ports are data inputs, they provide integer numerical values to the node from some other node. You'll notice that the \"B\" Port also has a numerical input field alongside it, this is because in this particular case the value that the Node uses can either be provided by another node via the Port or specified as a fixed value. In this example, you may want to compare the input from another Node at A with either an input from another Node or with 0 for example. If you connect another Node to the input Port B, the numerical input field will be hidden as it is no longer necessary. On the right of the Node are the output ports, in this example there are two Flow Ports, True and False. This Node is a \"branching\" node, it will perform a comparison of the two values A and B using the specified comparison type, for example \"equal\". If the comparison results in a positive result, i.e. the two values are equal, the flow will follow whatever is connected to the True output Port, if anything. If the comparison is negative, A and B are not equal, the flow will follow the False output Port. Below the B port is a Parameter, in this case it is the type of comparison to be made between A and B, equal, greater than, less than, etc. A Parameter can be identified by the lack of any input or output ports. It is a means of configuring the operation of a Node in a way that doesn't require input from another Node. To summarise, on this Node A is a Port only, it requires an input wire to work, B is an input Port or Parameter you can choose how this value is set depeneding upon your needs, and the comparison type is a Parameter, you must choose this value when editing and it cannot change at runtime.</p> <p> Some nodes will have no Flow ports at all, this means the Node is not meant to be part of the flow, but instead is meant to provide data to other nodes that are part of the flow. These Nodes will have output data Ports that can be connected to the input data Ports of other Nodes, when a Node that is part of a flow has a wire connecting one of its input Ports to the output Port of another Node, it will request the value from the other Node when it needs it.</p> <p>Nodes that are in a logic graph but not connected to a valid Flow or have output Ports that are not connected to anything, will not contribute to the program and will not be exported.</p> <p>There are currently two types of data port in Kwyll's logic, integer numerical, indicated by a green colour and connected by a green wire, and object reference, indicated by a blue colour and connected by a blue wire. It is only possible to connect two ports of the same type to one another, be that a Flow port or a type of data Port.</p>"},{"location":"logic/intro/#editing-nodes","title":"Editing Nodes","text":"<p>In the logic editor, Nodes are created by right clicking the mouse in an empty area of the grid, a pop-up menu will appear with a list of all the possible Node types. When one is selected it will appear in the graph at the mouse position. There is one more way to create Nodes via the variable list, which will be covered when that section of the logic editor is detailed.</p> <p>Click and drag on Nodes to move them around the graph and organise your program. You can Ctrl/Cmd click on multiple Nodes to select more than one at a time, or click and drag in space on the grid to drag a rectangle around a selection of Nodes.</p> <p> To connect Ports left click on one of the two Ports and drag, a wire will appear connected to the Port you clicked on and the mouse. Drag the mouse to the other Port and when you get close enough, it will snap to the Port, release the mouse to complete the connection. If you struggle to begin the connection operation because the port is too small, it can sometimes be helpful to zoom in, this can be achieved using the mouse wheel or pinch gesture. Ports can be connected in either direction, it makes no difference to the way they work, data only flows from output to input.</p> <p>To disconnect a port, click on the input end of the wire, the end going into the input port of a Node, drag it away from the port and it'll disconnect, you can reconnect to another port while still holding the mouse, or release the mouse with the wire disconnected to delete the wire altogether.</p>"},{"location":"logic/process_order/","title":"Logic Order of Processing","text":"<pre><code>graph TD \n    A[Start Game/Reset Game] --&gt; G1;\n    subgraph G1[Global];\n        B([Initialise]);\n    end;\n    G1 --&gt; S;\n    subgraph S[For Each Screen];\n        SA([Initialise]);\n    end;\n    S --&gt; R;\n    subgraph R[For Each Room];\n        direction LR;\n        RA([Initialise]) --&gt; RO;\n        subgraph RO[For Each Room Object];\n            RB([Initialise]);\n        end;\n    end;\n    R --&gt; G2;\n    subgraph G2[For Each Global Object];\n        C([Initialise]);\n    end;\n    G2 --&gt; FR;\n    subgraph FR[Each Frame];\n        subgraph G3[Global];\n            E([Always]);\n        end;\n        subgraph CS[Current Screen];\n            F([Always]);\n        end;\n        subgraph CR[Current Room];\n            G([Always]);\n            subgraph RO2[For Each Room Object];\n                H([Always]);\n            end;\n            G --&gt; RO2;\n        end;\n        subgraph GO[For Each Global Object];\n            J([Always]);\n        end;\n        G3 --&gt; CS;\n        CS --&gt; CR;\n        CR --&gt; GO;\n    end;</code></pre>"},{"location":"logic/nodes/always/","title":"Always","text":"<p> The Always Node is a specific type of Node called a Trigger. A trigger Node is an entrypoint into a flow in the Kwyll logic. Only if a logic program on an object or anything else has trigger nodes will the logic do anything. The Always trigger is the most common of trigger node, it will run the flow that follows on from it's flow output on every frame of the game.</p>"},{"location":"logic/nodes/always/#ports","title":"Ports","text":""},{"location":"logic/nodes/always/#flow-out","title":"Flow Out","text":"<p>As with all trigger nodes, an Always Node has only a single flow port on the output side. There is no input flow to a trigger node as it is the origin of a flow.</p>"},{"location":"logic/nodes/always/#parameters","title":"Parameters","text":""},{"location":"logic/nodes/always/#order","title":"Order","text":"<p>Always Nodes have a single additional parameter, order. This is used to define the order in which multiple Always Nodes in a single logic program will be processed, in case there is some dependency between flows. If there are multiple Always Nodes with the same order, they will be processed together in an arbitrary order.</p>"}]}