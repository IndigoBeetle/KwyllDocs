{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Kwyll","text":""},{"location":"#what-is-kwyll","title":"What is Kwyll?","text":"<p>If you're new to Kwyll, a quick introduction to what it is, why it is, and how it came about would probably be useful, so here goes.</p> <p>Kwyll is, at it's core, a tool for creating retro-styled games for retro platforms. What is \"retro\"? Well, in terms of Kwyll, it will initially include anything that existed at the start of the home computer revolution, so primarily 8-bit platforms, very low power, simple capabilities, such as the Sinclair ZX Spectrum, Commodore 64, Amstrad CPC, etc. It may extend beyond that in time, but that's the primary target. In its current form, Kwyll only targets the Sinclair ZX Spectrum (my personal favourite machine from the era).</p> <p>That covers what it is, why it is, well that's a longer story, but I'll try to keep it as short as I can. I've been involved with computers and software development since I was 14 years old (1983!), and my first, well actually second, my first was a ZX81, computer was a Sinclair ZX Spectrum, the 16K version which I later upgraded to 48K myself when I got the upgrade as a Christmas present from my parents. I've spent a good portion of my career working in games, starting on the 8-bit platforms of the time at Incentive Software. As such, these platforms hold a great deal of nostalgia for me, memories of a time I've always been very fond of. Fast forward to recent times, after a career working in the software industry, with some very complex systems including visual effects, VR, modern video games systems, FinTech etc. I found myself drawn back to the early days, when things were simpler and more fun, well, that's how I remember it anyway. A new wave of respect for retro tech. in all shapes and forms seems to be taking hold, which only added fuel to my desire to revisit those times. Then along comes the \"Spectrum Next\" project on Kickstarter. Unfortunately, I missed the first round, but definitely got in on the second. In anticipation of it's arrival, I determined I was going to be making some games like the good old days. I bought an Agon Light, a cheap Z80 based open source system that had gained some popularity just about the right time, and set to remembering how to program in Z80 again. While this was fun, I soon realised that this was not what I wanted to do, I guess I'd become too spoiled by modern tools and technologies. So, I decided the best way to do what I wanted to do was to make a tool to do it. I'd already gained some experience with this, being responsible for the 3D Construction Kit at Incentive, and having worked on in-house tools at various games companies in my career, I knew this was something I could do and enjoy doing. And so Kwyll was born, as with all the best projects, a means of scratching my own itch, that garnered some interest from the community and grew into something else.</p>"},{"location":"nav/","title":"Nav","text":"<ul> <li>Welcome</li> <li>Introduction</li> <li>Interface</li> <li>Logic</li> <li>Tutorials</li> </ul>"},{"location":"interface/assets_panel/","title":"Assets Panel","text":""},{"location":"interface/data_editor/","title":"Data Editor","text":""},{"location":"interface/kwyll_interface/","title":"The Kwyll Interface","text":"<p>Figure 1. Main Interface</p> <p>The main interface of Kwyll consists of a single window with a menu, toolbar, a tabbed main area and status bar. The menu is not shown in Main Interface, it is an operating system menu and as such on macOS displays at the top of the screen as per operating system guidelines, on Windows and Linux it may show at the top of the window above the toolbar.</p>"},{"location":"interface/kwyll_interface/#toolbar","title":"Toolbar","text":"<p>The toolbar contains shortcuts to commonly used functionality provided by the  menu functions, in order from left to right:</p>  New Game Clear the current game and start a new empty game.  Save Game Save the current game.  Load Game Load an existing game, replacing the currently open one.  Export Game Export the current game and build for running on a device or emulator.  Review Export Display a breakdown of the exported project for review, showing important   information such as how much memory is used by different parts of the game.  Undo Undo the last action taken. Kwyll keeps a list of all actions taken up to   the current point, allowing you to step back in history to undo changes made   or redo them. Once any number of undo steps are taken and a new change is made   the changes that could be redone are cleared and it no longer becomes possible   to redo from that point.  Redo Redo the last action undone.   Settings Edit game settings.   Settings Show information about the version and satus of your Kwyll installation."},{"location":"interface/kwyll_interface/#tabbed-area","title":"Tabbed Area","text":"<p>The main body of the Kwyll window is taken up by the tabbed area. Each editor that Kwyll has is in a separate tab in this area, including Screen, Data, Sprites, Objects, Rooms, Map, Sound, Logic and Preview.</p>"},{"location":"interface/kwyll_interface/#status-bar","title":"Status Bar","text":"<p>The status bar at the very bottom of the window is used to provide information about the game to the designer such as memory use.</p> <p></p> Memory Use Shows how much memory, in bytes, the game data currently uses out of how much   is available for use. If the usage exceeds the available space, the game will not work   on device or emulator."},{"location":"interface/logic_editor/","title":"Logic Editor","text":""},{"location":"interface/logic_editor/#editing-nodes","title":"Editing Nodes","text":"<p>Nodes are created by right clicking the mouse in an empty area of the grid or pressing Shift+A, a pop-up menu will appear with a list of all the possible Node types as a tree organised by category. The popup has, in addition to the list of nodes, a text entry field that will be focused by default, typing in here will filter the nodes list to only those that contain the typed text, this is a very efficient way to find the exact node you're looking for. As you type in the search field, the list will instantly adapt to show only the matching nodes, and the first in the list will be selected. You can add the selected node by pressing return, or use the Up and Down arrow keys to move among the nodes that match the search term to select before pressing return. As you become familiar with the available nodes, this will be the most efficient way to add nodes to the logic graph. Initially it may be better to use the mouse to scroll through the list and click on the node you require directly. Below the list of nodes is a small text field that will change to show a short description of the currently selected node.</p> <p>When a node is added to the graph, it will appear at the current mouse position.</p> <p>Click and drag on Nodes to move them around the graph and organise your program. You can Ctrl/Cmd click on multiple Nodes to select more than one at a time, or click and drag in space on the grid to drag a rectangle around a selection of Nodes.</p> <p> To connect Ports left click on one of the two Ports and drag, a wire will appear connected to the Port you clicked on and the mouse. Drag the mouse to the other Port and when you get close enough, it will snap to the Port, release the mouse to complete the connection. If you struggle to begin the connection operation because the port is too small, it can sometimes be helpful to zoom in, this can be achieved using the mouse wheel or pinch gesture. Ports can be connected in either direction, it makes no difference to the way they work, data only flows from output to input.</p> <p>To disconnect a port, click on the input end of the wire, the end going into the input port of a Node, drag it away from the port and it'll disconnect, you can reconnect to another port while still holding the mouse, or release the mouse with the wire disconnected to delete the wire altogether.</p>"},{"location":"interface/map_editor/","title":"Map Editor","text":""},{"location":"interface/nav/","title":"Nav","text":"<ul> <li>The Kwyll Interface</li> <li>Screen Editor</li> <li>Data Editor</li> <li>Sprite Editor</li> <li>Object Editor</li> <li>Room Editor</li> <li>Map Editor</li> <li>Sound Editor</li> <li>Logic Editor</li> <li>Preview</li> <li>Assets Panel</li> <li>Tilemap Editor</li> </ul>"},{"location":"interface/object_editor/","title":"Object Editor","text":""},{"location":"interface/preview/","title":"Preview","text":""},{"location":"interface/room_editor/","title":"Room Editor","text":""},{"location":"interface/screen_editor/","title":"Screen Editor","text":"<p>The Screen Editor is where in Kwyll you get to create and modify Screens. It is organised into four main areas, the Screens List, the Instruments List, the  Assets Panel and the Main Area.</p>"},{"location":"interface/screen_editor/#the-screens-list","title":"The Screens List","text":"<p>This is where you can select, add and remove the various screens that you have in your game. The local toolbar below the list includes buttons to create a new screen, delete the currently selected screen, and duplicate the currently selected screen, to the left side. It also has a button to edit the screen properties to the right. </p> <p></p>"},{"location":"interface/screen_editor/#screen-properties","title":"Screen Properties","text":"<p>The Screen Properties dialog is shown when double clicking a screen in the screens list, or clicking the screen properties button. This is where you can  modify various properties of the currently selected screen that are not editable in the main area layout and logic tabs.</p> Name The name of the screen. This is used in logic for example when selecting to    switch to a different screen, the Switch Screen   node will list the screen names in a dropdown control to make it easy to select   which screen to switch to. Game Screen? This toggles whether the screen should contain the game window or not. Typically   only one screen in your game will have the game window included, but it is    possible to have it in multiple screens, even in different places on the screen.   Some screens, such as a menu screen, a help screen, etc. will not require the   game window to be shown, they will consist entirely of instruments. Start Screen? This toggles if the screen should be the initial screen visible when starting    your game. Only one screen can have this flag set, so selecting it here will   automatically clear it on all other screens. The start screen is also shown in    the Screens List with a flag icon. Ink, Paper and Bright These combined set the default colours for the current screen. Instruments   can override these values. The paper colour is used as the background to the   entire screen. These values are also used as the default colours for tiles in   the screen tilemap unless replaced by painting attributes in the tilemap, or by   assigning colours to tiles. <p></p>"},{"location":"interface/screen_editor/#the-instruments-list","title":"The Instruments List","text":"<p>This is where you can select, add and remove the various Instruments defined in the currently selected screen. The local toolbar below the list includes buttons to create a new instrument and delete the currently selected instrument, to the left side. It also has a button to edit the instrument properties to the right. </p> <p></p> <p></p> <p>The Instrument Properties dialog is shown when double clicking on an instrument or clicking the instrument properties button. This is where you can modify the various  properties of an instrument.</p> Name The name of the instrument. This is used in logic for example when selecting to    update an instrument value, the Set Instrument   node will list the instrument names in a dropdown control to make it easy to select   which instrument to update. Position: This is the position on the screen for the top left corner of the instrument.    Instruments are placed on a grid of cells, each 8x8 pixels in size, so on the    Spectrum, the range of these values are 0 to 31 in X and 0 to 23 in Y, any values   beyond this range will result in the instrument being at least partially off screen. Size The size in cells of the instrument, as with the position, the instrument size is   specified in terms of cells, each 8x8 pixels in size. Type The type of the instrument. An instrument will display its Value in    different ways depending on the type of instrument. A text instrument will display   a string from the strings list, an integer instrument will display a numerical    value, and a tile instrument will show a single tile from the tileset. Value The initial value of the instrument, the meaning of the value depends on the   instrument type. Color These controls allow you to override the default colour information defined by the   screen. Ink and paper can be specified separately or ignored, choosing the black    colour with an \"X\" indicates that the instrument should not change the default for    ink or colour and instead use the value specified in the screen. The brightness value    can on or off, only if one of ink or paper is specified. <p></p>"},{"location":"interface/screen_editor/#assets-panel","title":"Assets Panel","text":"<p>The Assets Panel provides access to assets that can be placed in the screen editor view in addition to Instruments. It is a common element used in more than one editor in Kwyll, and as such has its ow separate  section of the documentation here. </p> <p></p>"},{"location":"interface/screen_editor/#main-area","title":"Main Area","text":"<p>The rest of the Screen Editor is taken up with the main area, where the majority of the editing of a Screen takes place. It consists of two tabs, Layout and Logic. The Logic tab is a standard Logic Editor component that is used to edit logic that applies to the current room, see Logic for more details.</p> <p>The Layout tab contains the screen layout editing tools. It consists of two parts, a  standard Tilemap Editor component, and layered on top of it a specific set of editing features for Screens. The Tilemap Editor is documented  separately as a common component.</p>"},{"location":"interface/screen_editor/#layout","title":"Layout","text":"<p>The screen Layout Editor works as a set of additional tools that operate in the same space as the Tilemap Editor. It provides visual tools for interactively placing screen elements such as Instruments and the Game Window.</p> <p>An Instrument is represented on the  grid as a yellow rectangle with a small triangle in the bottom right corner . You can click and drag the instrument on the grid, it will automatically conform to the grid cells, snapping to 8x8 increments. By carefully clicking on the small triangle in the corner, you can drag out the rectangle to change its size, again, it will automatically conform to  the grid.</p> <p>If the screen being edited has the Game Screen flag set in the properties, a blue rectangle will show to represent the Game Window. This element does not have a resize handle (triangle), as it's not possible to resize the game window in a screen, the game window size is fixed on all screens, the only way to modify the game window size is in the Settings dialog. However, the game window can be positioned independently on each screen it is used, so dragging the blue rectangle representing the game window works in much the same way as an Instrument, it will also conform to the grid as appropriate. </p> <p></p>"},{"location":"interface/sound_editor/","title":"Sound Editor","text":""},{"location":"interface/sprite_editor/","title":"Sprite Editor","text":""},{"location":"interface/tilemap_editor/","title":"Tilemap Editor","text":""},{"location":"introduction/terminology/","title":"Terminology","text":"<p>There are several stages to developing a game with Kwyll, each with their own section in the tool. Below is a short introduction to some of the terminology that you will come across frequently throughout this documentation, this is a good place to start to ensure that you have the best chance of understanding what is being described later in the guide.</p>"},{"location":"introduction/terminology/#sprites","title":"Sprites","text":"<p>Of course, any game needs some graphics, right? In Kwyll there are two main places you can draw pixel graphics, Sprites, and Tiles. A Sprite in Kwyll is a rectangular grid of pixels, Sprites can be various sizes, always in increments of 8 pixels in both axes. So, for example, 8x8, 16x16, 8x16, etc. An arbitrary limit is placed on the maximum size of 32 in either axis just to keep things within reason for the target platforms to maintain performance and limit memory use. </p> <p>It is important to know that a Sprite doesn't actually 'do' anything in Kwyll, it's just an image, it has no position, it isn't by default drawn to the screen anywhere, in order to get a Sprite onto the screen, it must be used by an Object.</p>"},{"location":"introduction/terminology/#objects","title":"Objects","text":"<p>An Object in Kwyll is a type of thing that can be displayed on screen and respond in various ways to the input of the player or to game logic that is defined in Kwyll. Objects are the heart of any Kwyll game, without Objects, the game wouldn't actually do anything, making for a very dull game. </p> <p>An Object must first be defined, the definition of an Object details things like the visual represenation via Sprites and any other information that is required to display the object that may be platform specific, such as colour and draw mode, and any Logic. </p> <p>However, an Object Definition does not contribute to the game iself, it has to be used. Objects can be used in Rooms and the Map, each use shares the visual representation and logic code from the Object Definition, but each use  has its own position, values for the variables defined in the logic, Timeline Animations, and any other information that might be specific to a particular platform. Objects can be used in the following ways.</p> <ul> <li>Map Objects - these are created in the Map    Editor and are constant throughout the game,    they will always exist irrespective of which Location you are    in, and will be drawn, if their position puts them on screen, and their logic    will be run.</li> <li>Room Objects - these are in each Room Definition and will only be    active while in a Location that uses that Room, so they will    not be drawn or their logic run when in location that uses another room.    It's worth noting that when exiting a room that contains Room Objects, the    data used by the Kwyll library for those objects, such as memory for    Sprite etc. will be freed, reducing the overhead for    both memory and performance, so it is advisable to use Room Objects where    appropriate over Map Objects.</li> <li>Dynamic Objects - these are not created in an editor during your game    creation, they are instead created during the game using the Spawn    Object node, and can be destroyed using the    Kill Object node. They are in all other    respects similar to Global Objects, they are not constrained to a particular    Room, and will continue to exist across changes in    Location until they are destroyed.</li> </ul> <p>An Object Definition consists of two main elements.</p> <ul> <li>Animations, which are sequences of Sprite images played in order    to create the illusion of animation. Each object can have many Animations,    for example, a player object might have an animation for walking left, one    for walking right, one for jumping, one for attacking etc. The game designer    can choose which Animation is played using the logic nodes based on what is    happening in the game at that moment.</li> <li>Logic is the \"brains\" of an Object, it defines what an Object does,    and when. In Kwyll, logic is created using a visual programming tool, a    powerful means of writing code without writing code.</li> </ul>"},{"location":"introduction/terminology/#tiles","title":"Tiles","text":"<p>Tiles are the simpler, more constrained, cousin to Sprites. They are also simple grid of pixels, however, a Tile is always 8x8 (unless a particular platform supports or requires a different size), and cannot be used in Objects, instead they are used in Rooms, typically to draw the background of a room, over which an Object's Sprites are drawn, and Screens, typically to draw borders or background graphics for a screen be it a menu screen, a game screen or any other use, and also as the content of an Instrument of the appropriate type.</p>"},{"location":"introduction/terminology/#tilemap","title":"Tilemap","text":""},{"location":"introduction/terminology/#rooms","title":"Rooms","text":"<p>A game in Kwyll consists of a number of Rooms, each room represents a separate space in the game, Kwyll does not currently support scrolling so gameplay is constrained to a single screen at a time, rooms allow you to move between these spaces. Each Room contains any combination of the following elements:</p> <ul> <li>A Tilemap, which represents the background of the room, such as the scenery,    walls, platforms, etc.</li> <li>Room Objects, which are unique to that room definition and are    only active while the room is active.</li> <li>Room Logic that is specific to the room defintion. Logic triggers    on a Room only run when a Location that uses the Room is the    current game location.</li> <li>Markers, very lightweight objects that only contain position information, no    sprites or logic, and are used primarily within Room or Object    Logic to place things within a room dynamically, for example, a    marker may be used as a spawn point for the player, or as a position to    appear when entering a room from another room.</li> </ul> <p>A Room Defintion, much like an Object Definition doesn't actually contribute to the game itself until it is used, in the case of a Room, the definition has to be used in the Map in a Location. The Map can contain multiple Locations that use the same Room Definition, much like an Object Definition can be used multiple times for Room and Map objects.</p>"},{"location":"introduction/terminology/#screens","title":"Screens","text":"<p>A Screen in Kwyll is a collection of Instruments, a Tilemap, and optionally, the game window. A screen can also have Logic associated with it that is run while that screen is the current screen. </p> <p>There is only one screen active at any time in a Kwyll game. Uses of screens include the main game screen which will have the game window positioned on the screen accordingly, a menu screen, instructions, and many others.</p>"},{"location":"introduction/terminology/#instruments","title":"Instruments","text":""},{"location":"introduction/terminology/#logic","title":"Logic","text":""},{"location":"introduction/terminology/#timeline-animation","title":"Timeline Animation","text":""},{"location":"introduction/terminology/#locations","title":"Locations","text":""},{"location":"introduction/terminology/#data","title":"Data","text":""},{"location":"logic/intro/","title":"What is Logic in Kwyll?","text":"<p>One of the most important aspects of a game created with Kwyll is the ability to make objects, and other things, \"do stuff\", this is achieved with the logic system that is built into Kwyll. It is akin to the programming language in other game creation tools, but instead of being text based, it is visual, working by wiring together small items that do a relatively simple thing so that the whole does something more interesting. </p> <p>These \"small items\" are called Nodes, Kwyll provides a basic set of Nodes that can be combined to do a variety of things, the process of \"wiring\" them together enables each Node to either pass data to another node, or to control the flow of the \"program\". Some of the Nodes are very simple, such as the Math Node, whose only job is to take in two values, perform a basic mathematical operation on them, add, subtract, multiply or divide, and then output the result. Others are more complex and perform a detailed operation in and of themselves based on the input and parameters.</p> <p>Each node has an optional set of input and output Ports which can be of different types depending on their purpose, and a set of Parameters which configure the operation of the Node.</p> <p> This  is a relatively simple Node that demonstrates most of the key features of a logic Node. Here you can see on the left of the Node; 3 input Ports, one with a double arrow at the top, and two green ones below. The double arrow port is a Flow port, it is connected to other ports of the same type to control the flow of execution. A Node will only have at most 1 Flow input port. The green ports are data inputs, they provide integer numerical values to the node from some other node. You'll notice that the \"B\" Port also has a numerical input field alongside it, this is a parameter, in this particular case the value that the Node uses can either be provided by another node via the Port or specified as a fixed value in the parameter. In this example, you may want to compare the input from another Node at A with either an input from another Node or with a specific fixed value, 0 in this case. If you connect another Node to the input Port B, the numerical input field will be hidden as it is no longer necessary. On the right of the Node are the output ports, in this example there are two Flow Ports, True and False. This Node is a \"branching\" node, it will perform a comparison of the two values A and B using the specified comparison type, for example \"equal\". If the comparison results in a true result, i.e. the two values are equal, the flow will follow whatever is connected to the True output Port, if anything. If the comparison is false, A and B are not equal, the flow will follow the False output Port. Below the B port is another Parameter, in this case it is the type of comparison to be made between A and B, equal, greater than, less than, etc. This Parameter has no input port, so it can only have a fixed value chosen at deisgn time. It is a means of configuring the operation of a Node in a way that doesn't require input from another Node. To summarise, on this Node A is a Port only, it requires an input wire to work, B is an input Port or Parameter you can choose how this value is set depeneding upon your needs, and the comparison type is a Parameter, you must choose this value when editing and it cannot change at runtime.</p> <p> Some nodes will have no Flow ports at all, this means the Node is not meant to be part of the flow, but instead is meant to provide data to other nodes that are part of the flow. These Nodes will have output data Ports that can be connected to the input data Ports of other Nodes, when a Node that is part of a flow has a wire connecting one of its input Ports to the output Port of another Node, it will request the value from the other Node when it needs it.</p> <p>Nodes that are in a logic graph but not connected to a valid Flow or have output Ports that are not connected to anything, will not contribute to the program and will not be exported.</p> <p>There are several types of data that can be passed between logic nodes in Kwyll,  each with a unique colour for the port and wires that connect them.</p> Number Shown as green, a signed 16 bit integer value,    capable of representing anything between -32768 and 32767. Object Shown as blue, a reference to an object in the    game, can be a Room object or a global object. Location Shown as magenta, a reference to a location    on the map."},{"location":"logic/intro/#editing-nodes","title":"Editing Nodes","text":"<p>See the Logic Editor for a detailed explanation of the tools for creating and editing logic graphs in Kwyll.</p>"},{"location":"logic/process_order/","title":"Logic Order of Processing","text":"<pre><code>graph TD \n    A[Start Game/Reset Game] --&gt; G1;\n    subgraph G1[Global];\n        B([Initialise]);\n    end;\n    G1 --&gt; S;\n    subgraph S[For Each Screen];\n        SA([Initialise]);\n    end;\n    S --&gt; R;\n    subgraph R[For Each Room];\n        direction LR;\n        RA([Initialise]) --&gt; RO;\n        subgraph RO[For Each Room Object];\n            RB([Initialise]);\n        end;\n    end;\n    R --&gt; G2;\n    subgraph G2[For Each Global Object];\n        C([Initialise]);\n    end;\n    G2 --&gt; FR;\n    subgraph FR[Each Frame];\n        subgraph G3[Global];\n            E([Always]);\n        end;\n        subgraph CS[Current Screen];\n            F([Always]);\n        end;\n        subgraph CR[Current Room];\n            G([Always]);\n            subgraph RO2[For Each Room Object];\n                H([Always]);\n            end;\n            G --&gt; RO2;\n        end;\n        subgraph GO[For Each Global Object];\n            J([Always]);\n        end;\n        G3 --&gt; CS;\n        CS --&gt; CR;\n        CR --&gt; GO;\n    end;</code></pre>"},{"location":"logic/nodes/always/","title":"Always","text":""},{"location":"logic/nodes/always/#description","title":"Description","text":"<p> The Always Node is a specific type of Node called a Trigger. A trigger Node is an entrypoint into a flow in the Kwyll logic. The Always trigger is the most commonly used trigger node, it will run the flow that follows on from it's Flow Out port every frame of the game.  </p> <p></p>"},{"location":"logic/nodes/always/#ports","title":"Ports","text":"Flow Out As with all trigger nodes, an Always Node has only a single flow port   on the output side. There is no input flow to a trigger node as it is   the origin of a flow."},{"location":"logic/nodes/always/#parameters","title":"Parameters","text":"Order Always Nodes have a single additional parameter, order. This is   used to define the order in which multiple Always Nodes in a single   logic program will be processed, in case there is some dependency   between flows. If there are multiple Always Nodes with the same order,   they will be processed together in an arbitrary order."},{"location":"logic/nodes/and/","title":"And","text":""},{"location":"logic/nodes/and/#description","title":"Description","text":"<p> The And Node takes two inputs of type integer and compares them with 0. If both are not 0, the output will be 1, if either or both are 0, the output will be 0. </p> <p>This is useful to combine checks, in particular with the Integer Compare node.</p> <p></p>"},{"location":"logic/nodes/and/#ports","title":"Ports","text":"A and B The two input values, they must be linked for the node to be operational and   can only be connected to sources that provide an integer value, such as   Get. Out The output of the node, will be either 1 or 0 depending on the result of   the compare."},{"location":"logic/nodes/animation_event/","title":"Animation Event","text":"<p> The Animation Event Node is a specific type of Node called a Trigger. A trigger Node is an entrypoint into a flow in the Kwyll logic. The Animation Event trigger is connected to the timeline animation feature in the Rooms Editor. It will run the flow that follows on from it's Flow Out port when a the current timeline animation for this object hits a keyframe that has the Trigger Event checkbox selected. The Frame and T output ports provide the frame number of the keyframe in the timeline, and the T value specified in the editor respectively.</p> <p></p>"},{"location":"logic/nodes/animation_event/#ports","title":"Ports","text":"Flow Out As with all trigger nodes, an Animation Event Node has only a single flow   port on the output side. There is no input flow to a trigger node as it is the   origin of a flow. Frame An integer output port that provides the frame number of the triggering   keyframe in the timeline. T An integer output port that provides the T value set in the timeline editor,   in the range 0-127."},{"location":"logic/nodes/beep_fx/","title":"Beep FX","text":""},{"location":"logic/nodes/beep_fx/#description","title":"Description","text":"<p> The Beep FX Node is used to play a beeper sound effect defined in the Beep FX panel of the Sound Editor. </p> <p></p>"},{"location":"logic/nodes/beep_fx/#ports","title":"Ports","text":"Flow In In order for this node to perform its operation, it must be connected into an   active flow using this input port. The flow will ultimately originate at a   Trigger node but can come from the Flow Out port of any other flow   node. Flow Out A node connected to the Flow Out port will be executed in sequence   following the completion of this node's operation. FX An integer input port used to provide the index of the Beep FX sound effect in   the list as defined by the Sound Editor."},{"location":"logic/nodes/beep_fx/#parameters","title":"Parameters","text":"FX A dropdown selection of existing sound effects from the Beep FX tab of the   Sound Editor. Use this if you wish to   trigger a specific sound effect, use the port at the same level in the node if   you wish to trigger a sound effect based on some calculations elsewhere in the   logic graph."},{"location":"logic/nodes/change_location/","title":"Change Location","text":""},{"location":"logic/nodes/change_location/#description","title":"Description","text":"<p> The Change Location Node is used to switch to another Location on the map. The location to change to will be wither the numerical index of the location on the map, you can find this by looking at the Map Editor and noting the number of the location displayed in the top left corner, or the location name if chosed from the provided dropdown.</p> <p>The Change Location node is only reqiured to switch to a new location if not using Auto Navigate, or in combination with Auto Navigate to transport to a new location that isn't  adjacent on the map, such as a hidden room or interior space for example.</p> <p></p>"},{"location":"logic/nodes/change_location/#ports","title":"Ports","text":"Flow In In order for this node to perform its operation, it must be connected into an   active flow using this input port. The flow will ultimately originate at a   Trigger node but can come from the Flow Out port of any other flow   node. Flow Out A node connected to the Flow Out port will be executed in sequence   following the completion of this node's operation. Location An integer input port used to provide the index of the map location as defined   in the Map Editor."},{"location":"logic/nodes/change_location/#parameters","title":"Parameters","text":"Location A dropdown selection of existing location names from the Map   Editor. Use this if you wish to change to a   specific location, use the port at the same level in the node if you wish to   use a location index based on some calculations elsewhere in the logic graph."},{"location":"logic/nodes/change_variable/","title":"Change Variable","text":""},{"location":"logic/nodes/change_variable/#description","title":"Description","text":"<p> The Change Variable Node is a simple way to modify the value of a variable on the current logic graph in one operation, avoiding the need for a Get, Math and Set sequence.</p> <p></p>"},{"location":"logic/nodes/change_variable/#ports","title":"Ports","text":"Flow In In order for this node to perform its operation, it must be connected into an   active flow using this input port. The flow will ultimately originate at a   Trigger node but can come from the Flow Out port of any other flow   node. Flow Out A node connected to the Flow Out port will be executed in sequence   following the completion of this node's operation. By An integer input port used to provide the amount that the variable will be    changed by, this can be positive or negative."},{"location":"logic/nodes/change_variable/#parameters","title":"Parameters","text":"By A constant integer amount that the variable will be changed by, used when the    By port is not connected. Variable A dropdown listing the defined variables associated with the current logic graph."},{"location":"logic/nodes/clamp/","title":"Clamp","text":""},{"location":"logic/nodes/clamp/#description","title":"Description","text":"<p> The Clamp Node takes an integer value on the In port, if the value is less than or equal to the Min port/parameter the Min port/parameter value is output, if it is greater than or equal to the Max port/parameter the Max port/parameter value is output, otherwise the value is output unmodified. </p> <p></p>"},{"location":"logic/nodes/clamp/#ports","title":"Ports","text":"In An integer input port used to provide the input value for testing. This must be   connected for the node to operate correctly. Out An integer output port, the result of the comparison detailed in the   description is output on this port. Min An integer input port, using this allows you to specify the minimum value from   elsewhere in the logic graph, such as via an Number node. Max An integer input port, using this allows you to specify the maximum value from   elsewhere in the logic graph, such as via an Number node."},{"location":"logic/nodes/clamp/#parameters","title":"Parameters","text":"Min A constant integer value for the minimum, used when the Min port is not   connected. Max A constant integer value for the maximum, used when the Max port is not   connected."},{"location":"logic/nodes/collided/","title":"Collided","text":""},{"location":"logic/nodes/collided/#description","title":"Description","text":"<p> The Collided Node is a specific type of Node called a Trigger. A trigger Node is an entrypoint into a flow in the Kwyll logic. The Collided trigger will get triggered when the object it is on has collided with the  tilemap as a result of being moved with a Move Object node.</p> <p></p>"},{"location":"logic/nodes/collided/#ports","title":"Ports","text":"Flow Out As with all trigger nodes, a Collided Node has only a single flow   port on the output side. There is no input flow to a trigger node as it is the   origin of a flow. Sides An integer output port that provides the sides that the collision occurred.    Typically this will be a single side, but to accommodate the potential of    simultaneously colliding with two sides, the value is encoded as a bit field.   That is, the first 4 bits of the binary representation encode the up, down,   left and right sides. Bit 0 is up, bit 1, down, bit 2 left and bit 3 right.  <p>An Example:      In this image, the object is moving in the direction of the green arrow, which    will result in it colliding in both right and up directions, as the tilemap has   collision information indicating that the tiles cannot be passed in all directions,   the resulting value will be bit 0 set and bit 3 set, bit 0 set results in a   value of 1, bit 3 set results in a value of 8, add them together and the output   of the Sides port would be 9.</p> <p>Bits:</p> 0 1 2 3 SIDE UP DOWN LEFT RIGHT VALUE 1 2 4 8"},{"location":"logic/nodes/comment/","title":"Comment","text":""},{"location":"logic/nodes/comment/#description","title":"Description","text":"<p> The Comment Node is a non-operational node, it doesn't connect to any flow or have any input or output ports or parameters. It has a single multi-line text field that you can enter any text into. The text will be saved with the game data, but typically has no bearing on the exported data. This node is usually used to provide some useful information in more complex logic graphs, a description of the operation of a certain part of the graph, or instructions on how to use a subgraph etc.</p> <p>It is resizable and will retain its size, allowing you to place it and size it to your requirements.</p> <p></p>"},{"location":"logic/nodes/compare/","title":"Compare","text":""},{"location":"logic/nodes/compare/#description","title":"Description","text":"<p> The Compare Node performs a comparison between two input values and  returns 0 if the comparison is fails, or 1 if it succeeds. </p> <p></p>"},{"location":"logic/nodes/compare/#ports","title":"Ports","text":"A An integer input port used to provide the first value for comparison.    This must be connected for the node to operate correctly. B An integer input port used to provide the second value for comparison. Result The output of the comparison, either 0 if the comparison fails or   1 if it succeeds."},{"location":"logic/nodes/compare/#parameters","title":"Parameters","text":"B A constant integer value for the B operand, used when the B port is not   connected. Comparison The type of comparison to perform, this can be any one of \"equals\",    \"greater than\", \"less than\", \"greater or equal\", \"less or equal\", or   \"not equal\"."},{"location":"logic/nodes/controller/","title":"Controller Input","text":""},{"location":"logic/nodes/controller/#description","title":"Description","text":"<p> The Controller Input Node reports on the status of the configured controller for left, right, up, down and jump/fire. This node will adapt to whatever has been configured for the input method in your game, joystick, keyboard etc. The node allows you to define which values to return when each input is activated, defaulting to 1 for each, so that you can define the appropriate values for your needs. For example, it might be common to use -1 for left and 1 for right, to be used directly later in the graph as directions on the X axis to avoid having to convert the input to a direction manually.</p> <p>The controller reports the status in one of four modes, Pressed, Released, Just Pressed and Just Released. The Pressed and Released modes will report continuously while the input is in the appropriate state, either pressed or not pressed. The Just Pressed and Just Released will report only for the frame after the input changes to the appropriate state, pressed or released. For example, Just Pressed will report only once when the player presses the key or joystick control, commonly used for fire actions, it will not report again until the player releases that input and then activates it again.</p> <p></p>"},{"location":"logic/nodes/controller/#ports","title":"Ports","text":"Left An integer output port that will report the result of checking the state of the   left controller input based on the mode. Right An integer output port that will report the result of checking the state of the   right controller input based on the mode. Up An integer output port that will report the result of checking the state of the   up controller input based on the mode. Down An integer output port that will report the result of checking the state of the   down controller input based on the mode. Jump/Fire An integer output port that will report the result of checking the state of the   jump/fire controller input based on the mode."},{"location":"logic/nodes/controller/#parameters","title":"Parameters","text":"Left A constant integer value that will be output on the Left port if the input   check matches the mode for the left input. Right A constant integer value that will be output on the Right port if the input   check matches the mode for the right input. Up A constant integer value that will be output on the Up port if the input   check matches the mode for the up input. Down A constant integer value that will be output on the Down port if the input  check matches the mode for the down input. Jump/Fire A constant integer value that will be output on the Jump/Fire port if the   input check matches the mode for the jump/fire input. Mode Define the mode of operation between Pressed, Released, Just Pressed and   Just Released. See the description of the node operation for an explanation   of the difference between the modes."},{"location":"logic/nodes/current_location/","title":"Current Location","text":""},{"location":"logic/nodes/current_location/#description","title":"Description","text":"<p> The Current Location Node simply returns a reference to the current location on  the map for use in other nodes or for storage in a variable for future reference.</p> <p></p>"},{"location":"logic/nodes/current_location/#ports","title":"Ports","text":"Out A location reference output port, provides a reference to the current location on    the map."},{"location":"logic/nodes/direction/","title":"Direction","text":""},{"location":"logic/nodes/direction/#description","title":"Description","text":"<p> The Direction Node is used to convert the typical four directional movement input into a single value representing the primary direction of movement. This is useful for things like switching sprite animation on Objects to show the correct animation for the movement. If the input suggests a diagonal movement, the output will be a single value representing the \"dominant\" axis as defined by the Vertical Priority parameter, if this is checked, then up/down will be chosen over left/right if diagonal movement is indicated, if it is not checked, left/right will get priority.</p> <p>Note: unlike other nodes with port/parameter pairs, in this node the direction rows are not port or parameter, both are required. The port is the input, usually from a Controller node, while the parameter represents the output value that will be used if that direction is determined to be the dominant direction. In the example here, if only the right controller is non-0, the Direction value output will be 2.</p> <p></p>"},{"location":"logic/nodes/direction/#ports","title":"Ports","text":"Left An integer input port providing the input value for the left direction, any   non-0 value will be considered movement in that direction.  Right An integer input port providing the input value for the right direction, any   non-0 value will be considered movement in that direction. Up An integer input port providing the input value for the up direction, any   non-0 value will be considered movement in that direction. Down An integer input port providing the input value for the down direction, any   non-0 value will be considered movement in that direction. Direction An integer output port, one of the four direction parameter values will be   output on this port depending on the input data and the Vertical Priority   parameter."},{"location":"logic/nodes/direction/#parameters","title":"Parameters","text":"Vertical Priority A boolean value indicating which axis to give priority to if diagonal   movement is indicated. If checked, up/down will get priority, otherwise   left/right will. Left A constant integer value that will be output on the Output port if the    inputs indicate movement left. Right A constant integer value that will be output on the Output port if the    inputs indicate movement right. Up A constant integer value that will be output on the Output port if the    inputs indicate movement up. Down A constant integer value that will be output on the Output port if the    inputs indicate movement down."},{"location":"logic/nodes/flow_in/","title":"Flow In","text":""},{"location":"logic/nodes/flow_in/#description","title":"Description","text":"<p> The Flow In Node is only used in Sub Graphs.  It marks the entrypoint for a flow contained in a sub graph. When a sub graph is used in another flow, this is the point that the execution continues when entering the sub graph node. </p> <p></p>"},{"location":"logic/nodes/flow_in/#ports","title":"Ports","text":"Flow Out The flow for the sub graph will begin with the node connected to this port.   The Flow Out nodes acts in a similar manner to Trigger nodes, in that it has   no input flow, as it defines the entryping to a sub graph flow."},{"location":"logic/nodes/get_global_object/","title":"Get Global Object","text":""},{"location":"logic/nodes/get_global_object/#description","title":"Description","text":"<p> The Get Global Object Node is used to get an Object Reference to a global object for use further down the graph in other nodes that accept a Ref input. This allows you to directly affect global objects, moving them, etc.</p> <p></p>"},{"location":"logic/nodes/get_global_object/#ports","title":"Ports","text":"Ref An Object Ref output port that will provide the reference to the requested   global object."},{"location":"logic/nodes/get_global_object/#parameters","title":"Parameters","text":"Object A dropdown selector that will list all the currently available global objects.   The value selected will dictate which Ref is returned."},{"location":"logic/nodes/get_location/","title":"Get Location","text":""},{"location":"logic/nodes/get_location/#description","title":"Description","text":"<p> The Get Location Node takes an integer value on the Location port and returns a reference to the location with that index on the map. The map editor displays the location index in the top left corner of each location.</p> <p></p>"},{"location":"logic/nodes/get_location/#ports","title":"Ports","text":"Location An integer input port used to provide the index of the location to get a reference to. Ref A location reference that points to the given location on the map."},{"location":"logic/nodes/get_location/#parameters","title":"Parameters","text":"Location A constant value for the location index. The user will be able to choose from a drop   down list of the existing location names, which will be stored internally as an index,   for convenience."},{"location":"logic/nodes/get_object_flags/","title":"Get Object Flags","text":""},{"location":"logic/nodes/get_object_flags/#description","title":"Description","text":"<p> The Get Object Flags Node allows the user to query the various flags on an object in the game. As the flags on an object are represented as bits in a larger value,  the actual number returned is the value of that bit in the flags, as detailed below for each  output port.</p> <p></p>"},{"location":"logic/nodes/get_object_flags/#ports","title":"Ports","text":"Ref An object reference port that provides a reference to the object to query the flags on.   If this is not connected, and the logic is on an object, the current object will be   used. Intersect Objects The value of the intersect objects flag. This is bit 2, if the flag is set the result   will be 4. Collide Bg The value of the collides with background flag. This is bit 1, if the flag is set the result   will be 2. Visible The value of the visible flag. This is bit 3, if the flag is set the result   will be 8. Active The value of the active flag. This is bit 4, if the flag is set the result   will be 16."},{"location":"logic/nodes/get_room_object/","title":"Get Room Object","text":""},{"location":"logic/nodes/get_room_object/#description","title":"Description","text":"<p> The Get Room Object Node is used to get an Object Reference to an object in a room for use further down the graph in other nodes that accept a Ref input. This allows you to directly affect room objects, moving them, etc.</p> <p></p>"},{"location":"logic/nodes/get_room_object/#ports","title":"Ports","text":"Ref An Object Ref output port that will provide the reference to the requested   global object."},{"location":"logic/nodes/get_room_object/#parameters","title":"Parameters","text":"Room A dropdown selector that will list all the currently available rooms.   When a room is selected, the contents of the Object selector will update   to list the object references in that room. Object A dropdown selector that will list all the currently available objects in the   selected room. The value selected will dictate which Ref is returned."},{"location":"logic/nodes/get_tile_information/","title":"Get Tile Information","text":""},{"location":"logic/nodes/get_tile_information/#description","title":"Description","text":"<p> The Get Tile Information Node takes input values X and Y in tile coordinates and provides back information about the tile at that location in the room tilemap.</p> <p>Note</p> <p>This tile only works for the room tilemap, not the screen tilemap.</p> <p></p>"},{"location":"logic/nodes/get_tile_information/#ports","title":"Ports","text":"X An integer input port used to provide the X value of the tile coordinate. Y An integer input port used to provide the Y value of the tile coordinate. Tile An integer output port, providing the tile number at the specified coordinates    if there is a tile there. If there is no tile, the output value with be -1. Collision An integer output port providing the collision flags at the specified coordinates.    The value is a bit field representing the sides of the tile that are marked as   preventing object movement. See collision. Colour An integer output port providing the colour information at the specified   coordinates. The colour is a combination of ink, paper and bright data as   described in colour. Type An integer output port providing the custom type of the tile at the specified   coordinates. If there is no tile at the specified location, the output value will   be 0. See tilemaps for details of tile types."},{"location":"logic/nodes/get_tile_information/#parameters","title":"Parameters","text":"X A constant integer value for the X coordinate, used when the X port is not   connected. Y A constant integer value for the Y coordinate, used when the Y port is not   connected."},{"location":"logic/nodes/get_variable/","title":"Get Variable","text":""},{"location":"logic/nodes/get_variable/#description","title":"Description","text":"<p> The Get Variable Node is used to get the integer value of a variable on whatever the current logic graph is running, i.e. a Screen, a Room or an Object.</p> <p>It's important to understand that, in the case of rooms and objects the value being accessed is the value for the chosen variable in the Object Reference or Location, that is running the logic code, each reference has it's own copy of the variables, they are independent.</p> <p></p>"},{"location":"logic/nodes/get_variable/#ports","title":"Ports","text":"Output An integer output port that will provide the value of the chosen variable."},{"location":"logic/nodes/get_variable/#parameters","title":"Parameters","text":"Variable A dropdown listing the defined variables associated with the current logic graph."},{"location":"logic/nodes/global_variable/","title":"Global Variable","text":""},{"location":"logic/nodes/global_variable/#description","title":"Description","text":"<p> The Global Variable Node is used to get the integer value of a variable on the global Logic.</p> <p></p>"},{"location":"logic/nodes/global_variable/#ports","title":"Ports","text":"Output An integer output port that will provide the value of the chosen variable."},{"location":"logic/nodes/global_variable/#parameters","title":"Parameters","text":"Variable A dropdown listing the defined variables associated with the global logic graph."},{"location":"logic/nodes/go_to_location_at/","title":"Go To Location At","text":""},{"location":"logic/nodes/go_to_location_at/#description","title":"Description","text":"<p> The Go To Location At Node takes input values X and Y that specify a position  on the map and will change to the Location at that point on the map if there is one. If there is no location at the specified coordinates, nothing happens.</p> <p></p>"},{"location":"logic/nodes/go_to_location_at/#ports","title":"Ports","text":"Flow In In order for this node to perform its operation, it must be connected into an   active flow using this input port. The flow will ultimately originate at a   Trigger node but can come from the Flow Out port of any other flow   node. Flow Out A node connected to the Flow Out port will be executed in sequence   following the completion of this node's operation. X An integer input port used to provide the X value of the map coordinate. Y An integer input port used to provide the Y value of the map coordinate."},{"location":"logic/nodes/go_to_location_at/#parameters","title":"Parameters","text":"X A constant integer value for the X coordinate, used when the X port is not   connected. Y A constant integer value for the Y coordinate, used when the Y port is not   connected."},{"location":"logic/nodes/if/","title":"If","text":""},{"location":"logic/nodes/if/#description","title":"Description","text":"<p> The If Node performs a comparison between two input values and  follows one of two flows depending on the result of the comparison.</p> <p></p>"},{"location":"logic/nodes/if/#ports","title":"Ports","text":"Flow In In order for this node to perform its operation, it must be connected into an   active flow using this input port. The flow will ultimately originate at a   Trigger node but can come from the Flow Out port of any other flow   node. True A node connected to the True port will be executed in sequence if the   result of the comparison succeeds. False A node connected to the False port will be executed in sequence if the   result of the comparison fails. A An integer input port used to provide the first value for comparison.    This must be connected for the node to operate correctly. B An integer input port used to provide the second value for comparison."},{"location":"logic/nodes/if/#parameters","title":"Parameters","text":"B A constant integer value for the B operand, used when the B port is not   connected. Comparison The type of comparison to perform, this can be any one of \"equals\",    \"greater than\", \"less than\", \"greater or equal\", \"less or equal\", or   \"not equal\"."},{"location":"logic/nodes/initialise/","title":"Initialise","text":""},{"location":"logic/nodes/initialise/#description","title":"Description","text":"<p> The Initialise Node is a specific type of Node called a Trigger. A trigger Node is an entrypoint into a flow in the Kwyll logic. The Initialise trigger will run the flow that follows on from it's Flow Out port only once at the start of the game.</p> <p></p>"},{"location":"logic/nodes/initialise/#ports","title":"Ports","text":"Flow Out As with all trigger nodes, an Initialse Node has only a single flow port   on the output side. There is no input flow to a trigger node as it is   the origin of a flow."},{"location":"logic/nodes/input/","title":"Input","text":""},{"location":"logic/nodes/input/#description","title":"Description","text":"<p> The Input Node represents an input value to a  Sub Graph. The provided name is used on the  sub graph node as the name for the input port that provides the value into the rest of the sub graph flow.</p> <p>See Sub Graphs for more information regarding the use of sub graphs.</p> <p></p>"},{"location":"logic/nodes/input/#ports","title":"Ports","text":"Out An output port, the value passed into the matching named port on the sub graph   node will be provided here to the rest of the nodes in the sub graph."},{"location":"logic/nodes/input/#parameters","title":"Parameters","text":"Name The name of the port on the sub graph that will represent this input value."},{"location":"logic/nodes/instance_data/","title":"Instance Data","text":""},{"location":"logic/nodes/instance_data/#description","title":"Description","text":"<p> The Instance Data Node provides useful information about the current Object Reference that the logic graph is running on. This is information that is unique to each reference of the object type, much like variables, but for accessing common data that all object references have.</p> <p>Note: the position data is returned in the appropriate coordinate system for the object being referenced. A global or dynamic object will return coordinates in \"map\" space, a room object will return coordinates in the local space of the room.</p> <p></p>"},{"location":"logic/nodes/instance_data/#ports","title":"Ports","text":"Ref An Object Reference input port that can provide an object that will be used   to lookup the instance data. If this is not connected and the logic is on   an Object, the current object   will be used instead. If the logic is not on an object, 0 will be returned   on all output ports. Start X The initial X position of the object, this is constant, and used to reset the    object's position at the start of the game. Start Y The initial Y position of the object, this is constant, and used to reset the    object's position at the start of the game. X The current X position of the object, this is the live position of the object   as set by any Move Object nodes, or other nodes that can   modify an object's position.  Y The current Y position of the object, this is the live position of the object   as set by any Move Object nodes, or other nodes that can   modify an object's position."},{"location":"logic/nodes/is_on_screen/","title":"Is On Screen?","text":""},{"location":"logic/nodes/is_on_screen/#description","title":"Description","text":"<p> The Is On Screen Node takes a reference to an object and checks if its position puts it in a potentially visible place in the game window. It will continue executing in one of the True or False paths depending on the outcome of the test.</p> <p>Note</p> <p>Potentially visible means in a location that is within the bounds of the  game window, the object could be on screen, but not visible if the visible flag is not set.</p> <p></p>"},{"location":"logic/nodes/is_on_screen/#ports","title":"Ports","text":"Flow In In order for this node to perform its operation, it must be connected into an   active flow using this input port. The flow will ultimately originate at a   Trigger node but can come from the Flow Out port of any other flow   node. Ref An object reference port that provides a reference to the object to check.   If this is not connected, and the logic is on an object, the current object will be   used. True A node connected to the True port will be executed in sequence if the   object is in a potentially visible position in the window. False A node connected to the False port will be executed in sequence if the   object is not in a potentially visible position in the window."},{"location":"logic/nodes/is_type/","title":"Is Type?","text":""},{"location":"logic/nodes/is_type/#description","title":"Description","text":"<p> The Is Type Node takes a reference to an object and checks if it uses the given object definition. It will continue executing in one of the True or False paths depending on the  outcome of the test.</p> <p></p>"},{"location":"logic/nodes/is_type/#ports","title":"Ports","text":"Flow In In order for this node to perform its operation, it must be connected into an   active flow using this input port. The flow will ultimately originate at a   Trigger node but can come from the Flow Out port of any other flow   node. Ref An object reference port that provides a reference to the object to check.   If this is not connected, and the logic is on an object, the current object will be   used. True A node connected to the True port will be executed in sequence if the   object uses the specified object definition. False A node connected to the False port will be executed in sequence if the   object does not use the specified object definition."},{"location":"logic/nodes/keyframe_animation/","title":"Keyframe Animation","text":""},{"location":"logic/nodes/keyframe_animation/#description","title":"Description","text":"<p> The Keyframe Animation Node is used to modify the settings for any  keyframe animations created on an object instance, currently only available for Room Objects. It can optionally change the current animation and/or the frame in the current or new animation.</p> <p></p>"},{"location":"logic/nodes/keyframe_animation/#ports","title":"Ports","text":"Flow In In order for this node to perform its operation, it must be connected into an   active flow using this input port. The flow will ultimately originate at a   Trigger node but can come from the Flow Out port of any other flow   node. Flow Out A node connected to the Flow Out port will be executed in sequence   following the completion of this node's operation. Ref An object reference port that provides a reference to the object to check.   If this is not connected, and the logic is on an object, the current object will be   used. Anim An integer port that provides the index of the animation to switch to. If the value   is -1, the current animation is not changed. Frame An integer port that provides the requested frame number on the current animation.   If the value is -1, the frame is not modified, unless a change in animation makes   the current frame number invalid."},{"location":"logic/nodes/keyframe_animation/#parameters","title":"Parameters","text":"Anim A constant integer value for the animation index, used when the Anim port is not   connected. Frame A constant integer value for the animation frame, used when the Frame port is not   connected."},{"location":"logic/nodes/kill_object/","title":"Kill Object","text":""},{"location":"logic/nodes/kill_object/#description","title":"Description","text":"<p> The Kill Object Node is used to remove a dynamic object that was created with the Spawn Object node. </p> <p>Note</p> <p>It is not possible to kill map or room objects, only those created with the Spawn Object node.</p> <p></p>"},{"location":"logic/nodes/kill_object/#ports","title":"Ports","text":"Flow In In order for this node to perform its operation, it must be connected into an   active flow using this input port. The flow will ultimately originate at a   Trigger node but can come from the Flow Out port of any other flow   node. Flow Out A node connected to the Flow Out port will be executed in sequence   following the completion of this node's operation. Ref An object reference port that provides a reference to the object to check.   If this is not connected, and the logic is on an object, the current object will be   used."},{"location":"logic/nodes/location_to_map/","title":"Location To Map","text":""},{"location":"logic/nodes/location_to_map/#description","title":"Description","text":"<p> The Location To Map Node takes input values X and Y that define a position  in the room coordinates of a specified Location  and converts the position into map coordinates.</p> <p>This is particularly useful for positioning a map level object so that it is at a  chosen point within a location.</p> <p></p>"},{"location":"logic/nodes/location_to_map/#ports","title":"Ports","text":"Location A location reference port that provides a reference to the location that the   provided coordinates are relative to. If not connected, and the logic is on   a location, the current location will be used. X An integer input port used to provide the X value of the location coordinate. Y An integer input port used to provide the Y value of the location coordinate."},{"location":"logic/nodes/location_to_map/#parameters","title":"Parameters","text":"X A constant integer value for the X coordinate, used when the X port is not   connected. Y A constant integer value for the Y coordinate, used when the Y port is not   connected."},{"location":"logic/nodes/location_variable/","title":"Location Variable","text":""},{"location":"logic/nodes/location_variable/#description","title":"Description","text":"<p> The Location Variable Node is used to get the integer value of a variable on a given Location.</p> <p></p>"},{"location":"logic/nodes/location_variable/#ports","title":"Ports","text":"Flow In In order for this node to perform its operation, it must be connected into an   active flow using this input port. The flow will ultimately originate at a   Trigger node but can come from the Flow Out port of any other flow   node. Valid A node connected to the Valid port will be executed in sequence if the   specified location is using the correct Room Definition. Invalid A node connected to the Invalid port will be executed in sequence if the   specified location is not using the correct Room Definition. Location A location reference port that provides a reference to the location that the   variable is to be queried on. If not connected, and the logic is on   a location, the current location will be used. Output An integer output port that will provide the value of the chosen variable."},{"location":"logic/nodes/location_variable/#parameters","title":"Parameters","text":"Variable A dropdown listing the defined variables associated with the specified location. Room Definition A dropdown listing the available room definitions. Only if the specified location   uses the room definition chosen will the variable output be valid."},{"location":"logic/nodes/map_to_location/","title":"Map To Location","text":""},{"location":"logic/nodes/map_to_location/#description","title":"Description","text":"<p> The Map To Location Node takes input values X and Y that define a position  in map coordinates  and converts the position to the room coordinates of a specified  Location.</p> <p>This is particularly useful for positioning a room level object so that it is at a chosen position on the map, presuming the position is within the bounds of the location.</p> <p></p>"},{"location":"logic/nodes/map_to_location/#ports","title":"Ports","text":"Location A location reference port that provides a reference to the location that the   resulting coordinates are relative to. If not connected, and the logic is on   a location, the current location will be used. X An integer input port used to provide the X value of the map coordinate. Y An integer input port used to provide the Y value of the map coordinate."},{"location":"logic/nodes/map_to_location/#parameters","title":"Parameters","text":"X A constant integer value for the X coordinate, used when the X port is not   connected. Y A constant integer value for the Y coordinate, used when the Y port is not   connected."},{"location":"logic/nodes/marker_position/","title":"Marker Position","text":""},{"location":"logic/nodes/marker_position/#description","title":"Description","text":"<p> The Marker Position Node queries the position of a  Marker in a given location, returning the position in room coordinates.</p> <p></p>"},{"location":"logic/nodes/marker_position/#ports","title":"Ports","text":"Location A location reference port that provides a reference to the location that the   provided coordinates are relative to. If not connected, and the logic is on   a location, the current location will be used. Marker An integer input port that provides the index of the marker to query. X An integer output port that provides the X value of the marker coordinate. Y An integer output port that provides the Y value of the marker coordinate."},{"location":"logic/nodes/marker_position/#parameters","title":"Parameters","text":"Marker A constant integer value for the marker index, used when the Marker port is not   connected."},{"location":"logic/nodes/math/","title":"Math","text":""},{"location":"logic/nodes/math/#description","title":"Description","text":"<p> The Math Node takes input values A and B and applies a mathematical operation to them returning the result of the operation.</p> <p></p>"},{"location":"logic/nodes/math/#ports","title":"Ports","text":"A An integer input port used to provide the left operand of the mathematical    operation. B An integer input port used to provide the right operand of the mathematical    operation. Result An integer output port that provides the result of the mathematical operation."},{"location":"logic/nodes/math/#parameters","title":"Parameters","text":"B A constant integer value for the right operand, used when the B port is not   connected. Operator The operation to perform on the two operands. A dropdown offers the choices, Add   Subtract, Multiply and Divide."},{"location":"logic/nodes/message_global_logic/","title":"Message Global Logic","text":""},{"location":"logic/nodes/message_global_logic/#description","title":"Description","text":"<p> The Message Global Logic Node sends a message to the global logic in your game. The global logic should have an On Message node  correctly configured to handle the message, otherwise it will have no effect.</p> <p>The ID of the message is used to choose which On Message flow will handle the message, and the optional parameters P1 and P2 are passed to the message handler to provide additional information that can be arbitrarily defined by the game designer.</p> <p></p>"},{"location":"logic/nodes/message_global_logic/#ports","title":"Ports","text":"Flow In In order for this node to perform its operation, it must be connected into an   active flow using this input port. The flow will ultimately originate at a   Trigger node but can come from the Flow Out port of any other flow   node. Flow Out A node connected to the Flow Out port will be executed in sequence   following the completion of this node's operation. ID An integer input port used to provide ID of the message, this controls which   flow on the global object will handle the message, only On Message   flows with a matchin ID will be executed. P1 An integer input port used to provide an arbitrary parameter to the handler, the   purpose of which is defined by the game designer. P2 An integer input port used to provide an arbitrary parameter to the handler, the   purpose of which is defined by the game designer."},{"location":"logic/nodes/message_global_logic/#parameters","title":"Parameters","text":"ID A constant integer value for the message ID, used when the ID port is not   connected. P1 A constant integer value for the optional P1 parameter, used when the P1    port is not connected. P2 A constant integer value for the optional P2 parameter, used when the P2    port is not connected."},{"location":"logic/nodes/message_location/","title":"Message Location","text":""},{"location":"logic/nodes/message_location/#description","title":"Description","text":"<p> The Message Location Node sends a message to a specified location.  The room logic for the location should have an On Message node  correctly configured to handle the message, otherwise it will have no effect.</p> <p>The ID of the message is used to choose which On Message flow will handle the message, and the optional parameters P1 and P2 are passed to the message handler to provide additional information that can be arbitrarily defined by the game designer.</p> <p></p>"},{"location":"logic/nodes/message_location/#ports","title":"Ports","text":"Flow In In order for this node to perform its operation, it must be connected into an   active flow using this input port. The flow will ultimately originate at a   Trigger node but can come from the Flow Out port of any other flow   node. Flow Out A node connected to the Flow Out port will be executed in sequence   following the completion of this node's operation. Location A location reference port that provides a reference to the location that the   message will be sent to. If not connected, and the logic is on a location,    the current location will be used. ID An integer input port used to provide ID of the message, this controls which   flow on the global object will handle the message, only On Message   flows with a matchin ID will be executed. P1 An integer input port used to provide an arbitrary parameter to the handler, the   purpose of which is defined by the game designer. P2 An integer input port used to provide an arbitrary parameter to the handler, the   purpose of which is defined by the game designer."},{"location":"logic/nodes/message_location/#parameters","title":"Parameters","text":"ID A constant integer value for the message ID, used when the ID port is not   connected. P1 A constant integer value for the optional P1 parameter, used when the P1    port is not connected. P2 A constant integer value for the optional P2 parameter, used when the P2    port is not connected."},{"location":"logic/nodes/message_object/","title":"Message Object","text":""},{"location":"logic/nodes/message_object/#description","title":"Description","text":"<p> The Message Object Node sends a message to a specified object. The object logic  should have an On Message node correctly configured to handle the  message, otherwise it will have no effect.</p> <p>The ID of the message is used to choose which On Message flow will handle the message, and the optional parameters P1 and P2 are passed to the message handler to provide additional information that can be arbitrarily defined by the game designer.</p> <p></p>"},{"location":"logic/nodes/message_object/#ports","title":"Ports","text":"Flow In In order for this node to perform its operation, it must be connected into an   active flow using this input port. The flow will ultimately originate at a   Trigger node but can come from the Flow Out port of any other flow   node. Flow Out A node connected to the Flow Out port will be executed in sequence   following the completion of this node's operation. Ref An object reference port that provides a reference to the object to check.   If this is not connected, and the logic is on an object, the current object will be   used. ID An integer input port used to provide ID of the message, this controls which   flow on the global object will handle the message, only On Message   flows with a matchin ID will be executed. P1 An integer input port used to provide an arbitrary parameter to the handler, the   purpose of which is defined by the game designer. P2 An integer input port used to provide an arbitrary parameter to the handler, the   purpose of which is defined by the game designer."},{"location":"logic/nodes/message_object/#parameters","title":"Parameters","text":"ID A constant integer value for the message ID, used when the ID port is not   connected. P1 A constant integer value for the optional P1 parameter, used when the P1    port is not connected. P2 A constant integer value for the optional P2 parameter, used when the P2    port is not connected."},{"location":"logic/nodes/message_screen/","title":"Message Screen","text":""},{"location":"logic/nodes/message_screen/#description","title":"Description","text":"<p> The Message Screen Node sends a message to specified screen. The screen logic should  have an On Message node correctly configured to handle the message,  otherwise it will have no effect.</p> <p>The ID of the message is used to choose which On Message flow will handle the message, and the optional parameters P1 and P2 are passed to the message handler to provide additional information that can be arbitrarily defined by the game designer.</p> <p></p>"},{"location":"logic/nodes/message_screen/#ports","title":"Ports","text":"Flow In In order for this node to perform its operation, it must be connected into an   active flow using this input port. The flow will ultimately originate at a   Trigger node but can come from the Flow Out port of any other flow   node. Flow Out A node connected to the Flow Out port will be executed in sequence   following the completion of this node's operation. ID An integer input port used to provide ID of the message, this controls which   flow on the global object will handle the message, only On Message   flows with a matchin ID will be executed. P1 An integer input port used to provide an arbitrary parameter to the handler, the   purpose of which is defined by the game designer. P2 An integer input port used to provide an arbitrary parameter to the handler, the   purpose of which is defined by the game designer."},{"location":"logic/nodes/message_screen/#parameters","title":"Parameters","text":"Screen The screen to send the message to. A dropdown will show a list of available   screens to select from. ID A constant integer value for the message ID, used when the ID port is not   connected. P1 A constant integer value for the optional P1 parameter, used when the P1    port is not connected. P2 A constant integer value for the optional P2 parameter, used when the P2    port is not connected."},{"location":"logic/nodes/modify_tiles/","title":"Modify Tiles","text":""},{"location":"logic/nodes/modify_tiles/#description","title":"Description","text":"<p> The Modify Tiles Node replaces information in the current location tilemap over a rectangular area with a single value. It is typically used to change  colour or collision information of a region, but can also be used to change the tiles in use, although the entire region would get the same tile.</p> <p>The Modify Tiles Node is a little different to many other nodes in the way it presents parameters, this is due to the fact that it can be used to modify  only certain properties of the tilemap. The primary difference in the  parameters is the inclusion of an additional checkbox for each with a small  X above it, this check box is used to indicate that the operation should ignore that property altogether. For example, selecting the X checkbox on the Collision property would ensure that the operation makes no  changes at all to the collision information in the areas specified.</p> <p></p>"},{"location":"logic/nodes/modify_tiles/#ports","title":"Ports","text":"Flow In In order for this node to perform its operation, it must be connected into an   active flow using this input port. The flow will ultimately originate at a   Trigger node but can come from the Flow Out port of any other flow   node. Flow Out A node connected to the Flow Out port will be executed in sequence   following the completion of this node's operation. X1 An integer input port used to provide the X value of the top left corner   of the area to be updated, in tile coordinates. Y1 An integer input port used to provide the Y value of the top left corner   of the area to be updated, in tile coordinates. X2 An integer input port used to provide the X value of the bottom right corner   of the area to be updated, in tile coordinates. Y2 An integer input port used to provide the Y value of the bottom right corner   of the area to be updated, in tile coordinates. Tile An integer input port used to provide the index of the tile to place in all   tilemap cells in the specified region. See the parameter description below   for more detail. Collision An integer input port used to provide the bit field information for the collision   of the tilemap cells in the specified region. See the parameter description below   for more detail. Ink An integer input port used to provide the ink colour of the tilemap cells in the    specified region. See the parameter description below for more detail. Paper An integer input port used to provide the paper colour of the tilemap cells in the    specified region. See the parameter description below for more detail. Bright An integer input port used to provide the bright setting of the tilemap cells in the    specified region. See the parameter description below for more detail."},{"location":"logic/nodes/modify_tiles/#parameters","title":"Parameters","text":"X1 A constant integer value for the X1 coordinate, used when the X1 port is not   connected. Y1 A constant integer value for the Y1 coordinate, used when the Y1 port is not   connected. X2 A constant integer value for the X2 coordinate, used when the X1 port is not   connected. Y2 A constant integer value for the Y2 coordinate, used when the Y1 port is not   connected. Tile A constant integer value to specify the tile to use, the preview to the right of the   numerical value will update to show the chosen tile. The checkbox with the trashcan   above indicates that the tile should be removed, not replaced. The checkbox with the    X above indicates that the tile should not be changed. Collision Four checkboxes indicate whether the tiles will have collision enabled in the up   down, left or right directions. The checkbox with the X above indicates that    the tile collision information should not be changed. Ink A colour selector to choose visually the ink colour to use for the tiles. The checkbox   with the X above indicates that the ink colour of the tiles should not be changed. Paper A colour selector to choose visually the paper colour to use for the tiles. The checkbox   with the X above indicates that the paper colour of the tiles should not be changed. Bright A checkbox to select whether the tiles will be bright or not. The checkbox   with the X above indicates that the brightness of the tiles should not be changed."},{"location":"logic/nodes/move_object/","title":"Move Object","text":""},{"location":"logic/nodes/move_object/#description","title":"Description","text":"<p> The Move Object Node takes input values X and Y that specify a position  to move the specified object to. </p> <p>When moving an object using this node, if the object has the Collide Bg flag enabled, the node will check if the movement results in a collision with the background tilemap and prevent it, resulting in a different endpoint to the requested one. If the object has the Intersect Objects flag enabled, the node will check if the final position results in it intersecting any other objects that have the same flag enabled. Any such intersections will result in the Object Hit flows on both objects being executed immediately.</p> <p>The X and Y coordinates are in the coordinate system that is appropriate for the object being moved. If the object is a room object, it expects the position to be in room coordinates, if it is a map object, it expects it to be in map  coordinates.</p> <p></p>"},{"location":"logic/nodes/move_object/#ports","title":"Ports","text":"Flow In In order for this node to perform its operation, it must be connected into an   active flow using this input port. The flow will ultimately originate at a   Trigger node but can come from the Flow Out port of any other flow   node. Flow Out A node connected to the Flow Out port will be executed in sequence   following the completion of this node's operation. Ref An object reference port that provides a reference to the object to check.   If this is not connected, and the logic is on an object, the current object will be   used. X An integer input port used to provide the X value of the new position. Y An integer input port used to provide the Y value of the new positio."},{"location":"logic/nodes/move_object/#parameters","title":"Parameters","text":"X A constant integer value for the X coordinate, used when the X port is not   connected. Y A constant integer value for the Y coordinate, used when the Y port is not   connected."},{"location":"logic/nodes/number/","title":"Number","text":""},{"location":"logic/nodes/number/#description","title":"Description","text":"<p> The Number Node simply provides a constant fixed number to be used as the input to other nodes. </p> <p>While most nodes offer constant parameters for integer input ports, this node can be useful when using the same input value for multiple nodes, as it allows you to change the value in one place rather than remembering to change it in multiple places, but still have the size and performance benefits of a constant value instead of a variable.</p> <p></p>"},{"location":"logic/nodes/number/#ports","title":"Ports","text":"Out An integer output port that provides the specified constant value."},{"location":"logic/nodes/number/#parameters","title":"Parameters","text":"Value A constant integer value to provide."},{"location":"logic/nodes/object_hit/","title":"Object Hit","text":"<p>  The Object Hit Node is a specific type of Node called a Trigger. A trigger Node is an entrypoint into a flow in the Kwyll logic. The Object Hit trigger is triggered automatically when any object that is configured to detect intersections with other objects is moved into a position where it intersects another that is also flagged to detect intersections with other objects. Any defined Object Hit flows on both objects involved in the intersection will be triggered.</p> <p></p>"},{"location":"logic/nodes/object_hit/#ports","title":"Ports","text":"Flow Out As with all trigger nodes, an Animation Event Node has only a single flow   port on the output side. There is no input flow to a trigger node as it is the   origin of a flow. Ref An object reference output port that provides a reference to the other object   involved in the intersection."},{"location":"logic/nodes/object_variable/","title":"Object Variable","text":""},{"location":"logic/nodes/object_variable/#description","title":"Description","text":"<p> The Object Variable Node is used to get the integer value of a variable on a given Object.</p> <p></p>"},{"location":"logic/nodes/object_variable/#ports","title":"Ports","text":"Flow In In order for this node to perform its operation, it must be connected into an   active flow using this input port. The flow will ultimately originate at a   Trigger node but can come from the Flow Out port of any other flow   node. Valid A node connected to the Valid port will be executed in sequence if the   specified object is using the correct Object Definition. Invalid A node connected to the Invalid port will be executed in sequence if the   specified object is not using the correct Object Definition. Ref An object reference port that provides a reference to the object to check.   If this is not connected, and the logic is on an object, the current object will be   used. Output An integer output port that will provide the value of the chosen variable."},{"location":"logic/nodes/object_variable/#parameters","title":"Parameters","text":"Variable A dropdown listing the defined variables associated with the specified location. Object Definition A dropdown listing the available object definitions. Only if the specified object   uses the object definition chosen will the variable output be valid."},{"location":"logic/nodes/on_message/","title":"On Message","text":""},{"location":"logic/nodes/on_message/#description","title":"Description","text":"<p> The On Message Node is a specific type of Node called a Trigger. A trigger Node is an entrypoint into a flow in the Kwyll logic. The On Message trigger is triggered manually within another flow by using the Message Room, Message Object, Message Screen or Message Global nodes.  </p> <p>A message consists of 3 parts, an ID and two optional parameters. The send message nodes have ports and parameters to set these values which control how this flow responds. The ID sent must match the ID defined in this flow for the flow to run. The parameters are typically used to control what the flow does. For example, a flow on a room that opens a door might take the side of the room that the door is on in P1 and the type of door in P2.</p> <p>The text field at the bottom of this node can be used to give a name to this message flow, it is used for informational purposes only, as a reminder to the designer of what this flow is responsible for.</p> <p></p>"},{"location":"logic/nodes/on_message/#ports","title":"Ports","text":"Flow Out As with all trigger nodes, an On Message Node has only a single flow port   on the output side. There is no input flow to a trigger node as it is   the origin of a flow. This flow is only followed if the ID of the message sent    matches the ID of this flow. P1 The value of the first parameter sent with the message, the Message nodes   have ports and parameters to define this, so each use of the message flow    can have different results based on the information passed in. P2 The value of the second parameter sent with the message, the Message nodes   have ports and parameters to define this, so each use of the message flow    can have different results based on the information passed in."},{"location":"logic/nodes/on_message/#parameters","title":"Parameters","text":"ID On Message Nodes have a single additional parameter, __ID. This is the    message ID that the flow will respond to. It is sent as part of the Message   send nodes. Using this ID it is possible to have multiple flows on an object,   room, screen or in the global logic that respond to different messages,   multiple \"functions\" if you will."},{"location":"logic/nodes/or/","title":"Or","text":""},{"location":"logic/nodes/or/#description","title":"Description","text":"<p> The Or Node takes two inputs of type integer and compares them with 0. If either or both are not 0, the output will be 1, if both are 0, the output will be 0. </p> <p>This is useful to combine checks, in particular with the Compare node.</p>"},{"location":"logic/nodes/or/#ports","title":"Ports","text":""},{"location":"logic/nodes/or/#a-and-b","title":"A and B","text":"<p>The two input values, they must be linked for the node to be operational and can only be connected to sources that provide an integer value, such as Get.</p>"},{"location":"logic/nodes/or/#out","title":"Out","text":"<p>The output of the node, will be either 1 or 0 depending on the result of the compare.</p>"},{"location":"logic/nodes/output/","title":"Output","text":""},{"location":"logic/nodes/output/#description","title":"Description","text":"<p> The Output Node represents an output value from a  Sub Graph. The provided name is used on the  sub graph node as the name for the output port.</p> <p>It is entirely normal to use the same name on multiple output ports, only one will provide the output value to the port on exiting the sub graph, the last one  encountered in the flow. This allows you to set the output to different values depending on the flow throught the sub graph.</p> <p>See Sub Graphs for more information regarding the use of sub graphs.</p> <p></p>"},{"location":"logic/nodes/output/#ports","title":"Ports","text":"In An input port, the value passed into this port will be provided up to the sub   graph node on exit."},{"location":"logic/nodes/output/#parameters","title":"Parameters","text":"Name The name of the port on the sub graph that will represent this output value."},{"location":"logic/nodes/paste_brush/","title":"Paste Brush","text":""},{"location":"logic/nodes/paste_brush/#description","title":"Description","text":"<p> The Paste Brush Node takes input values X and Y that specify a position  on the room tilemap in tile coordinates and will paste the contents of the  brush at the specified index into that location.</p> <p></p>"},{"location":"logic/nodes/paste_brush/#ports","title":"Ports","text":"Flow In In order for this node to perform its operation, it must be connected into an   active flow using this input port. The flow will ultimately originate at a   Trigger node but can come from the Flow Out port of any other flow   node. Flow Out A node connected to the Flow Out port will be executed in sequence   following the completion of this node's operation. X An integer input port used to provide the X value of the tilemap coordinate. Y An integer input port used to provide the Y value of the tilemap coordinate. Brush An integer input port used to specify the index of the brush to paste at the    given position."},{"location":"logic/nodes/paste_brush/#parameters","title":"Parameters","text":"X A constant integer value for the X coordinate, used when the X port is not   connected. Y A constant integer value for the Y coordinate, used when the Y port is not   connected. Brush A constant integer value for the brush index, used when the Brush port is not   connected."},{"location":"logic/nodes/pixel_to_tile/","title":"Pixel To Tile","text":""},{"location":"logic/nodes/pixel_to_tile/#description","title":"Description","text":"<p> The Pixel To Tile Node takes input values X and Y that specify a position  in pixel coordinates and converts them into tile coordinates.</p> <p>The coordinate system of the input, room or map, is not important, the conversion simply takes the pixel coordinate and returns the tile coordinate for the pixel at the position, irrespective of whether it is on screen, in the room, or not.</p> <p></p>"},{"location":"logic/nodes/pixel_to_tile/#ports","title":"Ports","text":"X An integer input port used to provide the X value of the pixel coordinate. Y An integer input port used to provide the Y value of the pixel coordinate. X Out An integer output port that provides the converted X value in tile coordinates. Y Out An integer output port that provides the converted Y value in tile coordinates."},{"location":"logic/nodes/pixel_to_tile/#parameters","title":"Parameters","text":"X A constant integer value for the X coordinate, used when the X port is not   connected. Y A constant integer value for the Y coordinate, used when the Y port is not   connected."},{"location":"logic/nodes/random/","title":"Random","text":""},{"location":"logic/nodes/random/#description","title":"Description","text":"<p> The Random Node provides a single random number between the Min and Max values provided.</p> <p></p>"},{"location":"logic/nodes/random/#ports","title":"Ports","text":"Min The minimum value, inclusive, of the random number. Max The maximum value, inclusive, of the random number. Value An integer output port that provides the generated random number."},{"location":"logic/nodes/random/#parameters","title":"Parameters","text":"Min A constant integer value for the minimum, used when the Min port is not   connected. Y A constant integer value for the maximum, used when the Max port is not   connected."},{"location":"logic/nodes/repeat/","title":"Repeat","text":""},{"location":"logic/nodes/repeat/#description","title":"Description","text":"<p>  The Repeat Node will run the node flow that is connected to its Body output port  repeatedly while an index is between the Start and Until values provided, altering  the index value each time around the loop by the Step value.</p> <p>The index is first set to the Start value, and then it is compared to the Until  value, if the Step is positive and the index is greater than or equal to the Until  value, the loop exits, similarly, if Step is negative and the index is less than or  equal to the Until value, the loop exits. That is, the loop runs while the index is  before the Until value, it is \"exclusive\".</p> <p>During the looping, the current value of the index can be accessed by nodes in the Body  using the Index port. Before execution, the index port is undefined, after execution  it will contain the last value of the index before exiting the loop.</p> <p>When the loop is complete, the logic graph will continue with the flow connected to the  Exit port.</p> <p></p>"},{"location":"logic/nodes/repeat/#ports","title":"Ports","text":"Flow In In order for this node to perform its operation, it must be connected into an   active flow using this input port. The flow will ultimately originate at a   Trigger node but can come from the Flow Out port of any other flow   node. Body The nodes that are to be repeatedly executed during the loop. Execution will    continue while there is a node connected to the Flow Out of the last node   executed, the body ends when there is no connection to the Flow Out, at which   point the index is updated and the node will check if it is to run the loop    again or exit. Start An integer port providing the start value of the index, this will be the value   of the index during the first run of the Body, it is \"inclusive\". Until An integer port providing the value to check the index against for exiting the   loop. The loop is exited before the index reaches this value. Step An integer port providing the value to add to the index each iteration through   the loop. This value can be positive or negative, allowing loops where the index   increases or decreases with each iteration. Index An integer output port that provides the current value of the index in the loop,    typically used by nodes within the Body flow. Exit A node connected to the Flow Out port will be executed in sequence   following the completion of this node's operation."},{"location":"logic/nodes/repeat/#parameters","title":"Parameters","text":"Start An integer input to specify a fixed value for the start of the loop index. Until An integer input to specify a fixed value for the exit point of the loop. Step An integer input to specify a fixed value to be added to the index each iteration   through the loop."},{"location":"logic/nodes/reset_game/","title":"Reset Game","text":""},{"location":"logic/nodes/reset_game/#description","title":"Description","text":"<p> The Reset Game Node resets the game. This operation returns all objects to  their initial position, runs the Initialise flows on all  objects, locations, screens and the global logic, and resets all variables to their initial values. It will delete all dynamically spawned objects. It will reset the starting location, but not modify the current screen.</p> <p></p>"},{"location":"logic/nodes/reset_game/#ports","title":"Ports","text":"Flow In In order for this node to perform its operation, it must be connected into an   active flow using this input port. The flow will ultimately originate at a   Trigger node but can come from the Flow Out port of any other flow   node. Flow Out A node connected to the Flow Out port will be executed in sequence   following the completion of this node's operation."},{"location":"logic/nodes/room_entered_trigger/","title":"Room Entered","text":""},{"location":"logic/nodes/room_entered_trigger/#description","title":"Description","text":"<p> The Room Entered Node is a specific type of Node called a Trigger. A trigger Node is an entrypoint into a flow in the Kwyll logic. The Room Entered trigger will run the flow that follows on from it's Flow Out port upon entering a location that uses the room definition that this logic flow is defined on.  </p> <p></p>"},{"location":"logic/nodes/room_entered_trigger/#ports","title":"Ports","text":"Flow Out As with all trigger nodes, an Room Entered Node has only a single flow port   on the output side. There is no input flow to a trigger node as it is   the origin of a flow."},{"location":"logic/nodes/room_exited_trigger/","title":"Room Exited","text":""},{"location":"logic/nodes/room_exited_trigger/#description","title":"Description","text":"<p> The Room Exited Node is a specific type of Node called a Trigger. A trigger Node is an entrypoint into a flow in the Kwyll logic. The Room Entered trigger will run the flow that follows on from it's Flow Out port upon exiting a location that uses the room definition that this logic flow is defined on.  </p> <p></p>"},{"location":"logic/nodes/room_exited_trigger/#ports","title":"Ports","text":"Flow Out As with all trigger nodes, an Room Entered Node has only a single flow port   on the output side. There is no input flow to a trigger node as it is   the origin of a flow."},{"location":"logic/nodes/screen_variable/","title":"Screen Variable","text":""},{"location":"logic/nodes/screen_variable/#description","title":"Description","text":"<p> The Screen Variable Node is used to get the integer value of a variable on the given Screen.</p> <p></p>"},{"location":"logic/nodes/screen_variable/#ports","title":"Ports","text":"Output An integer output port that will provide the value of the chosen variable."},{"location":"logic/nodes/screen_variable/#parameters","title":"Parameters","text":"Screen The screen to get the variable value from, a dropdown will present a list of   available screens to choose from. Variable A dropdown listing the defined variables associated with the specified screen."},{"location":"logic/nodes/select/","title":"Select","text":""},{"location":"logic/nodes/select/#description","title":"Description","text":"<p> The Select Node takes an index value and returns the corrent entry from a fixed list of integer values added to the node. Values are added using the  plus button, and can be reordered and removed using the buttons next to each list entry.</p> <p>The Mode parameter defines what the node will do if the provided index  is out of range for the number of items in the list. If it is set to Wrap any index greater than or equal to the number of items, as the index is zero based, will roll back round to the start again, so in a list with 3 items, if the  index provided was 4, the list entry at index 1 (the second in the list) will  be returned. Similarly, values less than 0 will roll round to the end of the list. If the Mode is Clamp, out of range values will be limited to 0 and  the number of items minus 1.</p> <p></p>"},{"location":"logic/nodes/select/#ports","title":"Ports","text":"Index An integer input port used to provide the index into the list. Out An integer output port that provides the value of the chose list item."},{"location":"logic/nodes/select/#parameters","title":"Parameters","text":"Index A constant integer value for the index, used when the Index port is not   connected. Mode The method to use to deal with out of range indices, Wrap or Clamp."},{"location":"logic/nodes/set_global_variable/","title":"Set Global Variable","text":""},{"location":"logic/nodes/set_global_variable/#description","title":"Description","text":"<p> The Set Global Variable Node is used to set the integer value of a variable on the Global Logic.</p> <p></p>"},{"location":"logic/nodes/set_global_variable/#ports","title":"Ports","text":"Flow In In order for this node to perform its operation, it must be connected into an   active flow using this input port. The flow will ultimately originate at a   Trigger node but can come from the Flow Out port of any other flow   node. Flow Out A node connected to the Flow Out port will be executed in sequence   following the completion of this node's operation. Value An integer input port used to provide the value that will be applied to the   chosen variable."},{"location":"logic/nodes/set_global_variable/#parameters","title":"Parameters","text":"Value A constant integer value to assign to the chosen variable. If the port is    connected to another node, this option will become unavailable, the node   will use the value provided on the input port. Variable A dropdown listing the defined variable names on the global logic graph."},{"location":"logic/nodes/set_instrument_value/","title":"Set Instrument","text":""},{"location":"logic/nodes/set_instrument_value/#description","title":"Description","text":"<p> The Set Instrument Node takes input values X and Y that specify a position  on the map and will change to the Location at that point on the map if there is one. If there is no location at the specified coordinates, nothing happens.</p> <p></p>"},{"location":"logic/nodes/set_instrument_value/#ports","title":"Ports","text":"Flow In In order for this node to perform its operation, it must be connected into an   active flow using this input port. The flow will ultimately originate at a   Trigger node but can come from the Flow Out port of any other flow   node. Flow Out A node connected to the Flow Out port will be executed in sequence   following the completion of this node's operation. Instrument An integer input port used to provide the index of the instrument on the screen. Value An integer input port used to provide the value to apply to the instrument."},{"location":"logic/nodes/set_instrument_value/#parameters","title":"Parameters","text":"Instrument A constant integer value for the instrument index, used when the Instrument    port is not connected. Value A constant integer value for the value, used when the Value port is not connected."},{"location":"logic/nodes/set_location_variable/","title":"Set Location Variable","text":""},{"location":"logic/nodes/set_location_variable/#description","title":"Description","text":"<p> The Set Location Variable Node is used to set the integer value of a variable on a given Location.</p> <p></p>"},{"location":"logic/nodes/set_location_variable/#ports","title":"Ports","text":"Flow In In order for this node to perform its operation, it must be connected into an   active flow using this input port. The flow will ultimately originate at a   Trigger node but can come from the Flow Out port of any other flow   node. Valid A node connected to the Valid port will be executed in sequence if the   specified location is using the correct Room Definition. Invalid A node connected to the Invalid port will be executed in sequence if the   specified location is not using the correct Room Definition. Location A location reference port that provides a reference to the location that contains   the variable to be modified. If not connected, and the logic is on   a location, the current location will be used. Value An integer input port that provides the value to be assigned to the chosen variable."},{"location":"logic/nodes/set_location_variable/#parameters","title":"Parameters","text":"Variable A dropdown listing the defined variables associated with the specified location. Room Definition A dropdown listing the available room definitions. Only if the specified location   uses the room definition chosen will the variable be modified and the valid flow   be followed."},{"location":"logic/nodes/set_object_colour/","title":"Set Object Colour","text":""},{"location":"logic/nodes/set_object_colour/#description","title":"Description","text":"<p> The Set Object Colour Node sets the colour information for the given object.</p> <p>The Set Object Colour Node is a little different to many other nodes in the way it presents parameters, this is due to the fact that it can be used to modify  only certain properties of the object colour. The primary difference in the  parameters is the inclusion of an additional checkbox for each with a small  X above it, this check box is used to indicate that the operation should ignore that property altogether. For example, selecting the X checkbox on the Ink property would ensure that the operation makes no  changes at all to the ink colour of the object.</p> <p></p>"},{"location":"logic/nodes/set_object_colour/#ports","title":"Ports","text":"Flow In In order for this node to perform its operation, it must be connected into an   active flow using this input port. The flow will ultimately originate at a   Trigger node but can come from the Flow Out port of any other flow   node. Flow Out A node connected to the Flow Out port will be executed in sequence   following the completion of this node's operation. Ref An object reference port that provides a reference to the object to change the colours   of. If not connected, and the logic is on an object, the current object will be used. Ink An integer input port used to provide the ink colour index. Paper An integer input port used to provide the paper colour index. Bright An integer input port used to provide the brightness setting, 0 is non-bright, and   other value is bright."},{"location":"logic/nodes/set_object_colour/#parameters","title":"Parameters","text":"Ink A colour selector to choose visually the ink colour to use for the object. The checkbox   with the X above indicates that the ink colour of the object should not be changed. Paper A colour selector to choose visually the paper colour to use for the object. The checkbox   with the X above indicates that the paper colour of the object should not be changed. Bright A checkbox to select whether the object will be bright or not. The checkbox   with the X above indicates that the brightness of the tiles should not be changed."},{"location":"logic/nodes/set_object_flags/","title":"Set Object Flags","text":""},{"location":"logic/nodes/set_object_flags/#description","title":"Description","text":"<p> The Set Object Flags Node is used to modify the flags on a given object. It can modify the flags that control whether the object registers intersection with other objects during moving, whether the object collides with the bacground tilemap or not, whether it is visible, and whether it is active.</p> <p>The Set Object Flags Node is slightly different to many nodes in regards to how the parameters are set. This is due to the fact that it can be used to only  affect certain flags, and leave others unchanged. To accommodate this, each  flag is represented by a \"three state checkbox\". The three states are  \"on\", \"off\", and \"leave\". If any are set to Leave, that flag will not be modified from its current state.</p> <p></p>"},{"location":"logic/nodes/set_object_flags/#ports","title":"Ports","text":"Flow In In order for this node to perform its operation, it must be connected into an   active flow using this input port. The flow will ultimately originate at a   Trigger node but can come from the Flow Out port of any other flow   node. Flow Out A node connected to the Flow Out port will be executed in sequence   following the completion of this node's operation. Ref An object reference port that provides a reference to the object to change ths flags   of. If not connected, and the logic is on an object, the current object will be used. Intersect Objects An integer input port used to provide the value of the Intersect Objects flag, 0   is off, any other value is on. Collide Bg An integer input port used to provide the value of the Collide Bg flag, 0   is off, any other value is on. Visible An integer input port used to provide the value of the Visible flag, 0   is off, any other value is on. Active An integer input port used to provide the value of the Active flag, 0   is off, any other value is on."},{"location":"logic/nodes/set_object_flags/#parameters","title":"Parameters","text":"Intersect Objects A constant value for the Intersect Objects flag, used when the Intersect Objects    port is not connected. If the value is Leave, the flag state will not be changed. Collide Bg A constant value for the Collide Bg flag, used when the Collide Bg    port is not connected. If the value is Leave, the flag state will not be changed. Visible A constant value for the Visible flag, used when the Visible    port is not connected. If the value is Leave, the flag state will not be changed. Active A constant value for the Active flag, used when the Active    port is not connected. If the value is Leave, the flag state will not be changed."},{"location":"logic/nodes/set_object_variable/","title":"Set Object Variable","text":""},{"location":"logic/nodes/set_object_variable/#description","title":"Description","text":"<p> The Set Object Variable Node is used to set the integer value of a variable on a given Object.</p> <p></p>"},{"location":"logic/nodes/set_object_variable/#ports","title":"Ports","text":"Flow In In order for this node to perform its operation, it must be connected into an   active flow using this input port. The flow will ultimately originate at a   Trigger node but can come from the Flow Out port of any other flow   node. Valid A node connected to the Valid port will be executed in sequence if the   specified location is using the correct Room Definition. Invalid A node connected to the Invalid port will be executed in sequence if the   specified location is not using the correct Room Definition. Ref An object reference port that provides a reference to the object that contains   the variable to be modified. If not connected, and the logic is on   an object, the current object will be used. Value An integer input port that provides the value to be assigned to the chosen variable."},{"location":"logic/nodes/set_object_variable/#parameters","title":"Parameters","text":"Variable A dropdown listing the defined variables associated with the specified object. Object Definition A dropdown listing the available object definitions. Only if the specified object   uses the object definition chosen will the variable be modified and the valid flow   be followed."},{"location":"logic/nodes/set_screen_variable/","title":"Set Screen Variable","text":""},{"location":"logic/nodes/set_screen_variable/#description","title":"Description","text":"<p> The Set Screen Variable Node is used to set the integer value of a variable on the given Screen.</p> <p></p>"},{"location":"logic/nodes/set_screen_variable/#ports","title":"Ports","text":"Flow In In order for this node to perform its operation, it must be connected into an   active flow using this input port. The flow will ultimately originate at a   Trigger node but can come from the Flow Out port of any other flow   node. Flow Out A node connected to the Flow Out port will be executed in sequence   following the completion of this node's operation. Value An integer input port that provides the value to assign to the chosen variable."},{"location":"logic/nodes/set_screen_variable/#parameters","title":"Parameters","text":"Screen The screen to get the variable value from, a dropdown will present a list of   available screens to choose from. Variable A dropdown listing the defined variables associated with the specified screen."},{"location":"logic/nodes/set_variable/","title":"Set Variable","text":""},{"location":"logic/nodes/set_variable/#description","title":"Description","text":"<p> The Set Variable Node is used to set the integer value of a variable on whatever the current logic graph is running, i.e. a Screen, a Room or an Object.</p> <p>It's important to understand that, in the case of rooms and objects the value being modified is the value for the chosen variable in the Object Reference or Location, that is running the logic code, each reference has it's own version of the variables, so changing a variable on one reference for a particular object type will not affect the value on other references, they are independent.</p> <p></p>"},{"location":"logic/nodes/set_variable/#ports","title":"Ports","text":"Flow In In order for this node to perform its operation, it must be connected into an   active flow using this input port. The flow will ultimately originate at a   Trigger node but can come from the Flow Out port of any other flow   node. Flow Out A node connected to the Flow Out port will be executed in sequence   following the completion of this node's operation. Value An integer input port used to provide the value that will be applied to the   chosen variable."},{"location":"logic/nodes/set_variable/#parameters","title":"Parameters","text":"Value A constant integer value to assign to the chosen variable. If the port is    connected to another node, this option will become unavailable, the node   will use the value provided on the input port. Variable A dropdown listing the defined variable names on the current logic graph."},{"location":"logic/nodes/spawn_object/","title":"Spawn Object","text":""},{"location":"logic/nodes/spawn_object/#description","title":"Description","text":"<p> The Spawn Object Node attempts to spawn a new dynamic object into the game. It takes an object definition, and if there is enough dynamic object capacity left, will create a new instance of that object definition as a map level dynamic object at the position in map coordinates specified in the X and Y values.</p> <p>If the operation succeeds, the flow will follow the Success flow, if it fails due to there being insufficient dynamic object slots available, it will follow the Fail flow.</p> <p>If the spawn operation succeeds, the Spawn Ref port will provide a reference to the spawned object for further modification or recording in a variable. If the spawn fails, this port value is undefined and should not be used.</p> <p></p>"},{"location":"logic/nodes/spawn_object/#ports","title":"Ports","text":"Flow In In order for this node to perform its operation, it must be connected into an   active flow using this input port. The flow will ultimately originate at a   Trigger node but can come from the Flow Out port of any other flow   node. Success A node connected to the Success port will be executed in sequence   following the successful completion of this node's operation. Fail A node connected to the Fail port will be executed in sequence   if the operation failed. X An integer input port used to provide the X value of the map coordinate. Y An integer input port used to provide the Y value of the map coordinate. Spawn Ref An object reference output port that provides a reference to the spawned object   if the operation succeeded."},{"location":"logic/nodes/spawn_object/#parameters","title":"Parameters","text":"X A constant integer value for the X coordinate, used when the X port is not   connected. Y A constant integer value for the Y coordinate, used when the Y port is not   connected. Object Definition A dropdown will provide a list of possible object types to choose from to spawn."},{"location":"logic/nodes/sprite_animation/","title":"Sprite Animation","text":""},{"location":"logic/nodes/sprite_animation/#description","title":"Description","text":"<p> The Sprite Animation Node is used to modify the settings for any  sprite animations created on an object instance. It can optionally  change the current animation, the rate and the frame in the current or new animation.</p> <p></p>"},{"location":"logic/nodes/sprite_animation/#ports","title":"Ports","text":"Flow In In order for this node to perform its operation, it must be connected into an   active flow using this input port. The flow will ultimately originate at a   Trigger node but can come from the Flow Out port of any other flow   node. Flow Out A node connected to the Flow Out port will be executed in sequence   following the completion of this node's operation. Ref An object reference port that provides a reference to the object to check.   If this is not connected, and the logic is on an object, the current object will be   used. Anim An integer port that provides the index of the animation to switch to. If the value   is -1, the current animation is not changed. Rate An integer port that provides the requested animation rate for the sprite animation.    If the value is -1, the rate is not modified. A value of 0 effectively stops the    sprite animation from playing. The rate is a delay between changing animation frame   in game frames. If the game is successfully running at 50fps, a value of 50 will make   the animation play at one frame per second. Frame An integer port that provides the requested frame number on the current animation.   If the value is -1, the frame is not modified, unless a change in animation makes   the current frame number invalid."},{"location":"logic/nodes/sprite_animation/#parameters","title":"Parameters","text":"Anim A constant integer value for the animation index, used when the Anim port is not   connected. Frame A constant integer value for the animation rate, used when the Rate port is not   connected. Frame A constant integer value for the animation frame, used when the Frame port is not   connected."},{"location":"logic/nodes/store_value/","title":"Store Value","text":""},{"location":"logic/nodes/store_value/#description","title":"Description","text":"<p> The Store Value Node takes a single input value and stores it for future use. When the Out value is requested, it returns the value that it stored, without running any nodes that connect to the In port as would normally happen.</p> <p>This node is very useful to optimise the execution of logic. Under normal conditions, whenever a node requests the value on any of its input ports, the logic will be executed on the node that connects to that port, and any nodes that connect to that node, and so on. This can be expensive if the value is used multiple times,  especially if it doesn't change. So putting a Store Value Node in place ensures that the calculation only happens once, and the resulting value is reused.</p> <p></p>"},{"location":"logic/nodes/store_value/#ports","title":"Ports","text":"Flow In In order for this node to perform its operation, it must be connected into an   active flow using this input port. The flow will ultimately originate at a   Trigger node but can come from the Flow Out port of any other flow   node. Flow Out A node connected to the Flow Out port will be executed in sequence   following the completion of this node's operation. In An integer input port used to provide the value to store for future use.   This port will only request its value once, no matter how many times the    Out port is used. Out An integer output port that provides the stored value."},{"location":"logic/nodes/sub_graph/","title":"Sub Graph","text":""},{"location":"logic/nodes/sub_graph/#description","title":"Description","text":"<p> The Subgraph Node is a dynamic node that represents a separate graph contained within it. The input and output ports on the Sub Graph Node will depend on the contents of the contained graph, specifically the use of Input and Output nodes. </p> <p>The node has an additional button not present on any other nodes, the down arrow on the top right of the node. Selecting this will open the graph contained within the sub graph for editing.</p> <p>See Sub Graphs for more information regarding the use of sub graphs.</p> <p></p>"},{"location":"logic/nodes/sub_graph/#ports","title":"Ports","text":"Flow In In order for this node to perform its operation, it must be connected into an   active flow using this input port. The flow will ultimately originate at a   Trigger node but can come from the Flow Out port of any other flow   node. Flow Out A node connected to the Flow Out port will be executed in sequence   following the completion of this node's operation."},{"location":"logic/nodes/switch_screen/","title":"Switch Screen","text":""},{"location":"logic/nodes/switch_screen/#description","title":"Description","text":"<p> The Switch Screen Node changes the current screen to the specified one.</p> <p></p>"},{"location":"logic/nodes/switch_screen/#ports","title":"Ports","text":"Flow In In order for this node to perform its operation, it must be connected into an   active flow using this input port. The flow will ultimately originate at a   Trigger node but can come from the Flow Out port of any other flow   node. Flow Out A node connected to the Flow Out port will be executed in sequence   following the completion of this node's operation."},{"location":"logic/nodes/switch_screen/#parameters","title":"Parameters","text":"Screen The screen to get the variable value from, a dropdown will present a list of   available screens to choose from."},{"location":"logic/nodes/tile_to_pixel/","title":"Tile To Pixel","text":""},{"location":"logic/nodes/tile_to_pixel/#description","title":"Description","text":"<p> The Tile To Pixel Node takes input values X and Y that specify a position  in tile coordinates and converts them into pixel coordinates.</p> <p>The coordinate system of the input, room or map, is not important, the conversion simply takes the pixel coordinate and returns the pixel coordinate for the tile at the position, irrespective of whether it is on screen, in the room, or not.</p> <p></p>"},{"location":"logic/nodes/tile_to_pixel/#ports","title":"Ports","text":"X An integer input port used to provide the X value of the tile coordinate. Y An integer input port used to provide the Y value of the tile coordinate. X Out An integer output port that provides the converted X value in pixel coordinates. Y Out An integer output port that provides the converted Y value in pixel coordinates."},{"location":"logic/nodes/tile_to_pixel/#parameters","title":"Parameters","text":"X A constant integer value for the X coordinate, used when the X port is not   connected. Y A constant integer value for the Y coordinate, used when the Y port is not   connected."},{"location":"logic/nodes/transport_object/","title":"Transport Object","text":""},{"location":"logic/nodes/transport_object/#description","title":"Description","text":"<p> The Transport Object Node takes input values X and Y that specify a position  to transport the specified object to.</p> <p>Transporting an object differs to the function of the Move Object node in that it performs no intersection testing or collision detection, it  simply moves it directly to the chosen position, as such, it is very fast and should be preferred for moving objects when intersection and collision are not important.</p> <p></p>"},{"location":"logic/nodes/transport_object/#ports","title":"Ports","text":"Flow In In order for this node to perform its operation, it must be connected into an   active flow using this input port. The flow will ultimately originate at a   Trigger node but can come from the Flow Out port of any other flow   node. Flow Out A node connected to the Flow Out port will be executed in sequence   following the completion of this node's operation. Ref An object reference port that provides a reference to the object to transport.   If this is not connected, and the logic is on an object, the current object will be   used. X A constant integer value for the X coordinate, used when the X port is not   connected. Y A constant integer value for the Y coordinate, used when the Y port is not   connected."},{"location":"logic/nodes/transport_object/#parameters","title":"Parameters","text":"X A constant integer value for the X coordinate, used when the X port is not   connected. Y A constant integer value for the Y coordinate, used when the Y port is not   connected."},{"location":"logic/nodes/transport_to_marker/","title":"Transport To Marker","text":""},{"location":"logic/nodes/transport_to_marker/#description","title":"Description","text":"<p> The Transport To Marker Node queries the position of a  Marker in a given location, and immediately transports the given object to that location, taking into account whether the object is a room object or a map object.</p> <p></p>"},{"location":"logic/nodes/transport_to_marker/#ports","title":"Ports","text":"Ref An object reference port that provides a reference to the object to transport.   If this is not connected, and the logic is on an object, the current object will be   used. Location A location reference port that provides a reference to the location that the   provided coordinates are relative to. If not connected, and the logic is on   a location, the current location will be used. Marker An integer input port that provides the index of the marker to query."},{"location":"logic/nodes/transport_to_marker/#parameters","title":"Parameters","text":"Marker A constant integer value for the marker index, used when the Marker port is not   connected."},{"location":"logic/nodes/while_loop/","title":"While Loop","text":""},{"location":"logic/nodes/while_loop/#description","title":"Description","text":"<p>  The While Loop Node will run the node flow that is connected to its Body output port  repeatedly while the result of evaluating the input at the Condition port is non-zero.</p> <p>When the loop is complete, the logic graph will continue with the flow connected to the  Exit port.</p> <p></p>"},{"location":"logic/nodes/while_loop/#ports","title":"Ports","text":"Flow In In order for this node to perform its operation, it must be connected into an   active flow using this input port. The flow will ultimately originate at a   Trigger node but can come from the Flow Out port of any other flow   node. Body The nodes that are to be repeatedly executed during the loop. Execution will    continue while there is a node connected to the Flow Out of the last node   executed, the body ends when there is no connection to the Flow Out, at which   point the index is updated and the node will check if it is to run the loop    again or exit. Condition An integer input port providing the value to check at each loop iteration.   If the value is 0, the loop exits, if it is non-zero, it loops again. Exit A node connected to the Flow Out port will be executed in sequence   following the completion of this node's operation."},{"location":"logic/nodes/wrap/","title":"Wrap","text":""},{"location":"logic/nodes/wrap/#description","title":"Description","text":"<p> The Wrap Node takes an integer value on the In port, if the value is less than 0, it will negate the value and subtract that from the Max  value minus 1, and repeat until it is greater than or equal to 0. </p> <p>If the input value is greater than or equal to the Max value, it will  subtract the Max value, and repeat until it is less than the Max value.</p> <p></p>"},{"location":"logic/nodes/wrap/#ports","title":"Ports","text":"In An integer input port used to provide the input value for testing. This must be   connected for the node to operate correctly. Out An integer output port, the result of the comparison detailed in the   description is output on this port. Max An integer input port, using this allows you to specify the maximum value from   elsewhere in the logic graph, such as via an Number node."},{"location":"logic/nodes/wrap/#parameters","title":"Parameters","text":"Max A constant integer value for the maximum, used when the Max port is not   connected."},{"location":"logic/nodes/z80_out/","title":"Z80 Out","text":""},{"location":"logic/nodes/z80_out/#description","title":"Description","text":"<p> The Z80 Out Node is a very special purpose node that allows you to perform an output operation on the Z80 in the Spectrum. It should be used with great care, as incorrect use can crash the machine.</p> <p>An example use is to change the border colour, setting the port to 254, and the value to a colour value between 0 and 7 will change the border colour.</p> <p></p>"},{"location":"logic/nodes/z80_out/#ports","title":"Ports","text":"Flow In In order for this node to perform its operation, it must be connected into an   active flow using this input port. The flow will ultimately originate at a   Trigger node but can come from the Flow Out port of any other flow   node. Flow Out A node connected to the Flow Out port will be executed in sequence   following the completion of this node's operation. Port An integer input port used to provide the port number to output the value to. Value An integer input port used to provide the value to output to the given port."},{"location":"logic/nodes/z80_out/#parameters","title":"Parameters","text":"Port A constant integer value for the port number, used when the Port port is not   connected. Value A constant integer value for the value to output, used when the Value port is not   connected."},{"location":"tutorials/simple_platformer_controller/","title":"Simple Platformer Controller","text":""},{"location":"tutorials/simple_platformer_controller/#how-to-create-a-simple-left-right-and-jump-platformer-controller","title":"How To Create A Simple, Left, Right and Jump Platformer Controller","text":"<p>One of the most common game genres for retro computers is the platformer, a game where the player typically has controls to move left and right, and to jump onto platforms and fall down when walking off a platform. This tutorial guides you through creating the logic nodes to create a player object in this style. While this very likely won't be adequate for a fully fledged game it should give some insights into some of the techniques that Kwyll offers to do this and serve as a starting point for customisation and improvement.</p>"},{"location":"tutorials/simple_platformer_controller/#setup","title":"Setup","text":""},{"location":"tutorials/simple_platformer_controller/#sprite","title":"Sprite","text":"<p>First, lets start by creating a sprite for our character, something simple as we're not focused on animation for this tutorial.</p> <p></p>"},{"location":"tutorials/simple_platformer_controller/#object","title":"Object","text":"<p>Then we'll turn this sprite into a simple object, our Player, remember to name it appropriately and set the draw mode to mask if you've drawn a mask for your player sprite. Add a single animation with one frame and choose the sprite you created for your character.</p> <p></p>"},{"location":"tutorials/simple_platformer_controller/#room","title":"Room","text":"<p>Next we'll setup a simple room to test out the player. Create a single simple tile, in the properties dialog, make sure to set the default collision to \"top\" as this will be the tile for our platforms, we want to be able to jump up through it, but then land on the top and not fall through.</p> <p></p> <p>Draw a ground and some platforms for our player to jump on using the tile we just created.</p> <p></p> <p>Drag the Player object from the objects panel onto the room. Note: normally the player would be a \"Map\" object, which allows it to travel between rooms, but for the purposes of this tutorial, we'll just have a single room, so we can just place our player in the room directly. </p> <p></p>"},{"location":"tutorials/simple_platformer_controller/#map","title":"Map","text":"<p>Finally, in order to be able to play the game, we must add the room to the map.</p> <p></p>"},{"location":"tutorials/simple_platformer_controller/#logic","title":"Logic","text":"<p>Now that we've got all the pieces in place, it's time to look at the core of this tutorial, the logic. In order to keep things clear, the different steps of the logic are implemented as separate flows, some of them could potentially be combined if you wanted to reduce the number of nodes, that is left as an exercise for the reader. </p> <p>We break the logic down into 5 steps, movement, jump triggering, fall processing and landing.</p> <p>Firstly, we'll need some variables to use during the logic, add the following variables to the Player object logic:</p> <ul> <li>speed</li> <li>can_jump</li> <li>y_velocity</li> <li>jump_strength</li> </ul> <p></p>"},{"location":"tutorials/simple_platformer_controller/#movement","title":"Movement","text":"<p>This flow is triggered by an \"Always\" trigger so will run every frame. It serves two purposes, checking the left right keys and altering the player's position in the horizontal direction, and applying any jump/fall amounts to adjust the player's position in the vertical direction. Once this is done, it will attempt to move the player to the new location.</p> <p></p> <p>Following the flow connections (white) you can see the first thing that happens after the flow is triggered is to set the \"can_jump\" variable to 0, this is so that should the move cause the player to fall off a platform they won't be able to jump, if the move does not cause the player to start falling, this flag will be reset by the Landing flow described below.</p> <p>The next thing in the flow is the actual move, this gets the X and Y position to move to from a set of calculations. Let's look at X first. </p> <p>The \"Controller Input\" node is configured to return -1 for left and 1 for right, if either button is not pressed, it will return 0 for that direction. These two values are added together in a \"Math\" node, this is to cancel out should the player press both left and right simultaneously, as 1 + -1 is 0, if only one button is pressed, the result will be either -1 or 1 depending on whether left or right is pressed.</p> <p>The result of this calculation is then fed into another \"Math\" node that multiplies the direction by the \"speed\" variable. The result of this calculation is then fed into a third \"Math\" node that adds it to the current X position of the player, moving it in the correct direction by the desired speed.</p> <p>The Y position is calculated by adding the \"y_velocity\" variable to the current Y position of the player.</p> <p>Finally, we try to move the player to the calculated new position.</p>"},{"location":"tutorials/simple_platformer_controller/#jump-triggering","title":"Jump Triggering","text":"<p>Next, in a separate \"Always\" flow, we check the jump button, note the \"Controller Input\" is set to \"Just Pressed\" for this, as we don't want the jump to be continuous as we do for the left/right movement, this is one good reason to keep the flows separate. </p> <p></p> <p>We get the result from the \"Controller Input\" to see if jump has just been pressed. We also get the value of the \"can_jump\" variable, and feed the result of both of these into an \"AND\" node. Only if the button is pressed, and the player can jump (both are 1), do we proceed to make the player jump. This is done by simply setting the \"y_velocity\" variable to minus the \"jump_strength\" variable, remember, negative in the Y direction is UP. We also set the \"can_jump\" to 0, this prevents the player from jumping again until they have landed.</p>"},{"location":"tutorials/simple_platformer_controller/#fall-processing","title":"Fall Processing","text":"<p>Next, in yet another \"Always\" flow, we continuously adjust the \"y_velocity\" to account for gravity. We clamp the value to always be between minus the \"jump_strength\" and 10, this ensures the player never goes up by more than the defined jump strength, and never falls faster than 10 pixels per frame.</p> <p></p>"},{"location":"tutorials/simple_platformer_controller/#landing","title":"Landing","text":"<p>Finally for now, we have the logic flow that reacts when the player has collided with something. The \"Collided\" trigger is automatically run when the \"Move Object\" node in the Movement flow results in the player hitting something. For the purposes of this tutorial, we know it can only be a platform or the ground, but we check the direction for completeness anyway and to ensure that collision in other directions is cleanly handled as you continue to develop your game around this controller.</p> <p></p> <p>The flow first checks if the sides includes \"TOP\" which is 2, it does this by logically ANDing the sides value with 2. Recall that the sides is a bit field, bit 0 (value 1 if collided) is UP, i.e. the move resulting in the object hitting something from below, bit 1 (value 2 if collided) is DOWN, bit 2 (value 4 if collided) is LEFT and bit 3 (value 8 if collided) is RIGHT. The actual valud of sides is a potential combination of these values, for example, if the object collided in both the DOWN and LEFT directions, the value will be 2 + 4 = 6, ANDing with 2, will remove any other directions from the value but the DOWN value, so if the player does collide both DOWN and LEFT, LEFT will be ignored, the output from 6 AND 2 is 2, as illustrated by the binary representation below. </p> <pre><code>            RLDU\n6       00000110\n2       00000010\n</code></pre> <p>Only if both \"bits\" in the binary number are 1, will the bit be 1 in the result, so the result of ANDing these two number will be 00000010 in binary, which is 2. This means we can just compare the result with 2 to check if the object collided in a downwards direction at all, irrespective of whether it collided in another direction as well or not.</p> <p>If this is true, we set \"can_jump\" variable to 1 to indicate that the player can now jump again as they have landed.</p>"},{"location":"tutorials/simple_platformer_controller/#testing","title":"Testing","text":"<p>Back in the Room Editor, open the object properties dialog for the player and make sure the \"Collide Bg\" flag is set so that the player object will collide with our platform tiles. </p> <p>In the Variables section of the object properties, you'll need to set the values of \"speed\" and \"jump_strength\" to suitable values, 1 and 7 will be good for our example, but you can tweak those as you choose.</p> <p></p> <p>That should be all that is required to get a basic platformer control working in Kwyll. Switch to the Preview tab and start the game, you should be able to move left and right, and jump up onto the platforms. When you walk off a platform the player should fall to the ground.</p> <p> </p>"}]}