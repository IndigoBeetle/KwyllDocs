{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Kwyll","text":""},{"location":"#what-is-kwyll","title":"What is Kwyll?","text":"<p>If you're new to Kwyll, a quick introduction to what it is, why it is, and how it came about would probably be useful, so here goes.</p> <p>Kwyll is, at it's core, a tool for creating retro-styled games for retro platforms. What is \"retro\"? Well, in terms of Kwyll, it will initially include anything that existed at the start of the home computer revolution, so primarily 8-bit platforms, very low power, simple capabilities, such as the Sinclair ZX Spectrum, Commodore 64, Amstrad CPC, etc. It may extend beyond that in time, but that's the primary target. In its current form, Kwyll only targets the Sinclair ZX Spectrum (my personal favourite machine from the era).</p> <p>That covers what it is, why it is, well that's a longer story, but I'll try to keep it as short as I can. I've been involved with computers and software development since I was 14 years old (1983!), and my first, well actually second, my first was a ZX81, computer was a Sinclair ZX Spectrum, the 16K version which I later upgraded to 48K myself when I got the upgrade as a Christmas present from my parents. I've spent a good portion of my career working in games, starting on the 8-bit platforms of the time at Incentive Software. As such, these platforms hold a great deal of nostalgia for me, memories of a time I've always been very fond of. Fast forward to recent times, after a career working in the software industry, with some very complex systems including visual effects, VR, modern video games systems, FinTech etc. I found myself drawn back to the early days, when things were simpler and more fun, well, that's how I remember it anyway. A new wave of respect for retro tech. in all shapes and forms seems to be taking hold, which only added fuel to my desire to revisit those times. Then along comes the \"Spectrum Next\" project on Kickstarter. Unfortunately, I missed the first round, but definitely got in on the second. In anticipation of it's arrival, I determined I was going to be making some games like the good old days. I bought an Agon Light, a cheap Z80 based open source system that had gained some popularity just about the right time, and set to remembering how to program in Z80 again. While this was fun, I soon realised that this was not what I wanted to do, I guess I'd become too spoiled by modern tools and technologies. So, I decided the best way to do what I wanted to do was to make a tool to do it. I'd already gained some experience with this, being responsible for the 3D Construction Kit at Incentive, and having worked on in-house tools at various games companies in my career, I knew this was something I could do and enjoy doing. And so Kwyll was born, as with all the best projects, a means of scratching my own itch, that garnered some interest from the community and grew into something else.</p>"},{"location":"nav/","title":"Nav","text":"<ul> <li>Welcome</li> <li>Introduction</li> <li>Interface</li> <li>Logic</li> </ul>"},{"location":"interface/data_editor/","title":"Data Editor","text":""},{"location":"interface/logic_editor/","title":"Logic Editor","text":""},{"location":"interface/logic_editor/#editing-nodes","title":"Editing Nodes","text":"<p>Nodes are created by right clicking the mouse in an empty area of the grid, a pop-up menu will appear with a list of all the possible Node types. When one is selected it will appear in the graph at the mouse position. </p> <p>Click and drag on Nodes to move them around the graph and organise your program. You can Ctrl/Cmd click on multiple Nodes to select more than one at a time, or click and drag in space on the grid to drag a rectangle around a selection of Nodes.</p> <p> To connect Ports left click on one of the two Ports and drag, a wire will appear connected to the Port you clicked on and the mouse. Drag the mouse to the other Port and when you get close enough, it will snap to the Port, release the mouse to complete the connection. If you struggle to begin the connection operation because the port is too small, it can sometimes be helpful to zoom in, this can be achieved using the mouse wheel or pinch gesture. Ports can be connected in either direction, it makes no difference to the way they work, data only flows from output to input.</p> <p>To disconnect a port, click on the input end of the wire, the end going into the input port of a Node, drag it away from the port and it'll disconnect, you can reconnect to another port while still holding the mouse, or release the mouse with the wire disconnected to delete the wire altogether.</p>"},{"location":"interface/map_editor/","title":"Map Editor","text":""},{"location":"interface/nav/","title":"Nav","text":"<ul> <li>Introduction</li> <li>Screen Editor</li> <li>Data Editor</li> <li>Sprite Editor</li> <li>Object Editor</li> <li>Room Editor</li> <li>Map Editor</li> <li>Sound Editor</li> <li>Logic Editor</li> <li>Preview</li> </ul>"},{"location":"interface/object_editor/","title":"Object Editor","text":""},{"location":"interface/preview/","title":"Preview","text":""},{"location":"interface/room_editor/","title":"Room Editor","text":""},{"location":"interface/screen_editor/","title":"Screen Editor","text":""},{"location":"interface/sound_editor/","title":"Sound Editor","text":""},{"location":"interface/sprite_editor/","title":"Sprite Editor","text":""},{"location":"introduction/terminology/","title":"Terminology","text":"<p>There are several stages to developing a game with Kwyll, each with their own section in the tool. Below is a short introduction to some of the terminology that you will come across frequently throughout this documentation, this is a good place to start to ensure that you have the best chance of understanding what is being described later in the guide.</p>"},{"location":"introduction/terminology/#sprites","title":"Sprites","text":"<p>Of course, any game needs some graphics, right? In Kwyll there are two main places you can draw pixel graphics, Sprites, and Tiles. A Sprite in Kwyll is a rectangular grid of pixels, Sprites can be various sizes, always in increments of 8 pixels in both axes. So, for example, 8x8, 16x16, 8x16, etc. An arbitrary limit is placed on the maximum size of 32 in either axis just to keep things within reason for the target platforms to maintain performance and limit memory use. </p> <p>It is important to know that a Sprite doesn't actually 'do' anything in Kwyll, it's just an image, it has no position, it isn't by default drawn to the screen anywhere, in order to get a Sprite onto the screen, it must be used by an Object.</p>"},{"location":"introduction/terminology/#objects","title":"Objects","text":"<p>An Object in Kwyll is a type of thing that can be displayed on screen and respond in various ways to the input of the player or to game logic that is defined in Kwyll. Objects are the heart of any Kwyll game, without Objects, the game wouldn't actually do anything, making for a very dull game. </p> <p>An Object must first be defined, the definition of an Object details things like the visual represenation via Sprites and any other information that is required to display the object that may be platform specific, such as colour and draw mode, and any Logic. To use an Object in your game requires creating Object References or Refs. These are instances of the object definition, they share the visual representation and logic code that the Object Definition holds, but each Ref has it's own position, logic variables, Timeline Animations, and any other information that might be specific to a particular platform. Object References can be created in the following ways.</p> <ul> <li>Global Objects - these are created in the Map    Editor and are constant throughout the game,    they will always exist irrespective of which Location you are    in, and will be drawn, if their position puts them on screen, and their    logic will be executed.</li> <li>Local or Room Objects - these are in each Room Definition and will    only be active while in a Location that references that room,    so they will not be drawn or their logic executed when in another room. It's    worth noting that when exiting a room that contains Room Objects, the data    used by the Kwyll library for those objects, such as memory for    Sprite rendering etc. will be freed, reducing the overhead for    both memory and performance, so it is advisable to use Room Objects where    appropriate over Global Objects.</li> <li>Dynamic Objects - these are not created in an editor during your game    creation, they are instead created during the game using the Spawn    Object node, and can be destroyed using the    Kill Object node. They are in all other    respects similar to Global Objects, they are not constrained to a particular    Room, and will continue to exist across changes in    Location until they are destroyed.</li> </ul> <p>An Object Definition consists of two main elements.</p> <ul> <li>Animations, which are sequences of Sprite images played in order    to create the illusion of animation. Each object can have many Animations,    for example, a player object might have an animation for walking left, one    for walking right, one for jumping, one for attacking etc. The game designer    can choose which Animation is played using the logic nodes based on what is    happening in the game at that moment.</li> <li>Logic is the \"brains\" of an Object, it defines what an Object    does, and when. In Kwyll, logic is created using a visual programming tool    that we'll get into later, a powerful means of writing code without writing    code.</li> </ul>"},{"location":"introduction/terminology/#tiles","title":"Tiles","text":"<p>Tiles are the simpler, more constrained, cousin to Sprites. They are also simple grid of pixels, however, a Tile is always 8x8, and cannot be used in Objects, instead they are used in Rooms, typically to draw the background of a room, over which an Object's Sprites are drawn, and Screens, typically to draw borders or background graphics for a screen be it a menu screen, a game screen or any other use.</p> <p>Unlike Sprites, Tiles do not have their own separate editor in Kwyll, the tools to create, edit and modify Tiles are integrated into the Room and Screen editors, as they are simple and it is convenient to have their editing tools in place in the editors where you use tiles. This choice means it's very efficient to work with Tiles when drawing your Rooms and Screens, with all the tools you need in one place.</p>"},{"location":"introduction/terminology/#rooms","title":"Rooms","text":"<p>A game in Kwyll consists of a number of 'rooms', each room represents a separate space in the game, Kwyll does not currently support scrolling so gameplay is constrained to a single screen at a time, rooms allow you to move between these spaces. Each room contains any combination of the following elements:</p> <ul> <li>A Tilemap, which represents the background of the room, such as the scenery,    walls, platforms, etc.</li> <li>Room Objects, which are unique to that room definition and are    only active while the room is active.</li> <li>Room Logic that is specific to the room defintion, the Always    triggers on Room Logic are only executed while the room is active.</li> <li>Markers, very lightweight objects that only contain position information, no    sprites or logic, and are used primarily within Room or Object    Logic to place things within a room dynamically, for example, a    marker may be used as a spawn point for the player, or as a position to    appear when entering a room from another room.</li> </ul>"},{"location":"introduction/terminology/#screens","title":"Screens","text":""},{"location":"introduction/terminology/#logic","title":"Logic","text":""},{"location":"introduction/terminology/#timeline-animation","title":"Timeline Animation","text":""},{"location":"introduction/terminology/#locations","title":"Locations","text":""},{"location":"logic/intro/","title":"What is Logic in Kwyll?","text":"<p>One of the most important aspects of a game created with Kwyll is the ability to make objects, and other things, \"do stuff\", this is achieved with the logic system that is built into Kwyll. It is akin to the programming language in other game creation tools, but instead of being text based, it is visual, working by wiring together small items that do a relatively simple thing so that the whole does something more interesting. </p> <p>These \"small items\" are called Nodes, Kwyll provides a basic set of Nodes that can be combined to do a variety of things, the process of \"wiring\" them together enables each Node to either pass data to another node, or to control the flow of the \"program\". Some of the Nodes are very simple, such as the Math Node, whose only job is to take in two values, perform a basic mathematical operation on them, add, subtract, multiply or divide, and then output the result. Others are more complex and perform a detailed operation in and of themselves based on the input and parameters.</p> <p>Each node has an optional set of input and output Ports which can be of different types depending on their purpose, and a set of Parameters which configure the operation of the Node.</p> <p> This is a relatively simple Node that demonstrates most of the key features of a logic Node. Here you can see on the left of the Node; 3 input Ports, one with a double arrow at the top, and two green ones below. The double arrow port is a Flow port, it is connected to other ports of the same type to control the flow of execution. A Node will only have at most 1 Flow input port. The green ports are data inputs, they provide integer numerical values to the node from some other node. You'll notice that the \"B\" Port also has a numerical input field alongside it, this is a parameter, in this particular case the value that the Node uses can either be provided by another node via the Port or specified as a fixed value in the parameter. In this example, you may want to compare the input from another Node at A with either an input from another Node or with a specific fixed value, 0 in this case. If you connect another Node to the input Port B, the numerical input field will be hidden as it is no longer necessary. On the right of the Node are the output ports, in this example there are two Flow Ports, True and False. This Node is a \"branching\" node, it will perform a comparison of the two values A and B using the specified comparison type, for example \"equal\". If the comparison results in a true result, i.e. the two values are equal, the flow will follow whatever is connected to the True output Port, if anything. If the comparison is false, A and B are not equal, the flow will follow the False output Port. Below the B port is another Parameter, in this case it is the type of comparison to be made between A and B, equal, greater than, less than, etc. This Parameter has no input port, so it can only have a fixed value chosen at deisgn time. It is a means of configuring the operation of a Node in a way that doesn't require input from another Node. To summarise, on this Node A is a Port only, it requires an input wire to work, B is an input Port or Parameter you can choose how this value is set depeneding upon your needs, and the comparison type is a Parameter, you must choose this value when editing and it cannot change at runtime.</p> <p> Some nodes will have no Flow ports at all, this means the Node is not meant to be part of the flow, but instead is meant to provide data to other nodes that are part of the flow. These Nodes will have output data Ports that can be connected to the input data Ports of other Nodes, when a Node that is part of a flow has a wire connecting one of its input Ports to the output Port of another Node, it will request the value from the other Node when it needs it.</p> <p>Nodes that are in a logic graph but not connected to a valid Flow or have output Ports that are not connected to anything, will not contribute to the program and will not be exported.</p> <p>There are currently two types of data port in Kwyll's logic, integer numerical, indicated by a green colour and connected by a green wire, and Object Reference, indicated by a blue colour and connected by a blue wire. It is only possible to connect two ports of the same type to one another, be that a Flow port or a type of data Port.</p>"},{"location":"logic/intro/#editing-nodes","title":"Editing Nodes","text":"<p>See the Logic Editor for a detailed explanation of the tools for creating and editing logic graphs in Kwyll.</p>"},{"location":"logic/process_order/","title":"Logic Order of Processing","text":"<pre><code>graph TD \n    A[Start Game/Reset Game] --&gt; G1;\n    subgraph G1[Global];\n        B([Initialise]);\n    end;\n    G1 --&gt; S;\n    subgraph S[For Each Screen];\n        SA([Initialise]);\n    end;\n    S --&gt; R;\n    subgraph R[For Each Room];\n        direction LR;\n        RA([Initialise]) --&gt; RO;\n        subgraph RO[For Each Room Object];\n            RB([Initialise]);\n        end;\n    end;\n    R --&gt; G2;\n    subgraph G2[For Each Global Object];\n        C([Initialise]);\n    end;\n    G2 --&gt; FR;\n    subgraph FR[Each Frame];\n        subgraph G3[Global];\n            E([Always]);\n        end;\n        subgraph CS[Current Screen];\n            F([Always]);\n        end;\n        subgraph CR[Current Room];\n            G([Always]);\n            subgraph RO2[For Each Room Object];\n                H([Always]);\n            end;\n            G --&gt; RO2;\n        end;\n        subgraph GO[For Each Global Object];\n            J([Always]);\n        end;\n        G3 --&gt; CS;\n        CS --&gt; CR;\n        CR --&gt; GO;\n    end;</code></pre>"},{"location":"logic/nodes/always/","title":"Always","text":""},{"location":"logic/nodes/always/#description","title":"Description","text":"<p> The Always Node is a specific type of Node called a Trigger. A trigger Node is an entrypoint into a flow in the Kwyll logic. The Always trigger is the most commonly used trigger node, it will run the flow that follows on from it's Flow Out port every frame of the game.  </p> <p></p>"},{"location":"logic/nodes/always/#ports","title":"Ports","text":"Flow Out As with all trigger nodes, an Always Node has only a single flow port   on the output side. There is no input flow to a trigger node as it is   the origin of a flow."},{"location":"logic/nodes/always/#parameters","title":"Parameters","text":"Order Always Nodes have a single additional parameter, order. This is   used to define the order in which multiple Always Nodes in a single   logic program will be processed, in case there is some dependency   between flows. If there are multiple Always Nodes with the same order,   they will be processed together in an arbitrary order."},{"location":"logic/nodes/and/","title":"And","text":""},{"location":"logic/nodes/and/#description","title":"Description","text":"<p> The And Node takes two inputs of type integer and compares them with 0. If both are not 0, the output will be 1, if either or both are 0, the output will be 0. </p> <p>This is useful to combine checks, in particular with the Integer Compare nodes.</p> <p></p>"},{"location":"logic/nodes/and/#ports","title":"Ports","text":"A and B The two input values, they must be linked for the node to be operational and   can only be connected to sources that provide an integer value, such as   Get. Out The output of the node, will be either 1 or 0 depending on the result of   the compare."},{"location":"logic/nodes/anim_event/","title":"Animation Event","text":"<p> The Animation Event Node is a specific type of Node called a Trigger. A trigger Node is an entrypoint into a flow in the Kwyll logic. The Animation Event trigger is connected to the timeline animation feature in the Rooms Editor. It will run the flow that follows on from it's Flow Out port when a the current timeline animation for this object hits a keyframe that has the Trigger Event checkbox selected. The Frame and T output ports provide the frame number of the keyframe in the timeline, and the T value specified in the editor respectively.</p> <p></p>"},{"location":"logic/nodes/anim_event/#ports","title":"Ports","text":"Flow Out As with all trigger nodes, an Animation Event Node has only a single flow   port on the output side. There is no input flow to a trigger node as it is the   origin of a flow. Frame An integer output port that provides the frame number of the triggering   keyframe in the timeline. T An integer output port that provides the T value set in the timeline editor,   in the range 0-127."},{"location":"logic/nodes/beep_fx/","title":"Beep FX","text":""},{"location":"logic/nodes/beep_fx/#description","title":"Description","text":"<p> The Beep FX Node is used to play a beeper sound effect defined in the Beep FX panel of the Sound Editor. </p> <p></p>"},{"location":"logic/nodes/beep_fx/#ports","title":"Ports","text":"Flow In In order for this node to perform its operation, it must be connected into an   active flow using this input port. The flow will ultimately originate at a   Trigger node but can come from the Flow Out port of any other flow   node. Flow Out A node connected to the Flow Out port will be executed in sequence   following the completion of this node's operation. FX An integer input port used to provide the index of the Beep FX sound effect in   the list as defined by the Sound Editor."},{"location":"logic/nodes/beep_fx/#parameters","title":"Parameters","text":"FX A dropdown selection of existing sound effects from the Beep FX tab of the   Sound Editor. Use this if you wish to   trigger a specific sound effect, use the port at the same level in the node if   you wish to trigger a sound effect based on some calculations elsewhere in the   logic graph."},{"location":"logic/nodes/change_location/","title":"Change Location","text":""},{"location":"logic/nodes/change_location/#description","title":"Description","text":"<p> The Change Location Node is used to switch to another Location on the map. </p> <p></p>"},{"location":"logic/nodes/change_location/#ports","title":"Ports","text":"Flow In In order for this node to perform its operation, it must be connected into an   active flow using this input port. The flow will ultimately originate at a   Trigger node but can come from the Flow Out port of any other flow   node. Flow Out A node connected to the Flow Out port will be executed in sequence   following the completion of this node's operation. Location An integer input port used to provide the index of the map location as defined   in the Map Editor."},{"location":"logic/nodes/change_location/#parameters","title":"Parameters","text":"Location A dropdown selection of existing location indices from the Map   Editor. Use this if you wish to change to a   specific location, use the port at the same level in the node if you wish to   use a location based on some calculations elsewhere in the logic graph."},{"location":"logic/nodes/clamp/","title":"Clamp","text":""},{"location":"logic/nodes/clamp/#description","title":"Description","text":"<p> The Clamp Node takes an integer value on the In port, if the value is less than or equal to the Min port/parameter the Min port/parameter value is output, if it is greater than or equal to the Max port/parameter the Max port/parameter value is output, otherwise the value is output unmodified. </p> <p></p>"},{"location":"logic/nodes/clamp/#ports","title":"Ports","text":"In An integer input port used to provide the input value for testing. This must be   connected for the node to operate correctly. Out An integer output port, the result of the comparison detailed in the   description is output on this port. Min An integer input port, using this allows you to specify the minimum value from   elsewhere in the logic graph, such as via an Integer   Constant node. Max An integer input port, using this allows you to specify the maximum value from   elsewhere in the logic graph, such as via an Integer   Constant node."},{"location":"logic/nodes/clamp/#parameters","title":"Parameters","text":"Min A constant integer value for the minimum, used when the Min port is not   connected. Max A constant integer value for the maximum, used when the Max port is not   connected."},{"location":"logic/nodes/comment/","title":"Comment","text":""},{"location":"logic/nodes/comment/#description","title":"Description","text":"<p> The Comment Node is a non-operational node, it doesn't connect to any flow or have any input or output ports or parameters. It has a single multi-line text field that you can enter any text into. The text will be saved with the game data, but typically has no bearing on the exported data. This node is usually used to provide some useful information in more complex logic graphs, a description of the operation of a certain part of the graph, or instructions on how to use a subgraph etc.</p> <p>It is resizable and will retain its size, allowing you to place it and size it to your requirements.</p> <p></p>"},{"location":"logic/nodes/controller/","title":"Controller","text":""},{"location":"logic/nodes/controller/#description","title":"Description","text":"<p> The Controller Node reports on the status of the configured controller for left, right, up, down and jump/fire. This node will adapt to whatever has been configured for the input method in your game, joystick, keyboard etc. The node allows you to define which values to return when each input is activated, defaulting to 1 for each, so that you can define the appropriate values for your needs. For example, it might be common to use -1 for left and 1 for right, to be used directly later in the graph as directions on the X axis to avoid having to convert the input to a direction manually.</p> <p>The controller reports the status in one of four modes, Pressed, Released, Just Pressed and Just Released. The Pressed and Released modes will report continuously while the input is in the appropriate state, either pressed or not pressed. The Just Pressed and Just Released will report only for the frame after the input changes to the appropriate state, pressed or released. For example, Just Pressed will report only once when the player presses the key or joystick control, commonly used for fire actions, it will not report again until the player releases that input and then activates it again.</p> <p></p>"},{"location":"logic/nodes/controller/#ports","title":"Ports","text":"Left An integer output port that will report the result of checking the state of the   left controller input based on the mode. Right An integer output port that will report the result of checking the state of the   right controller input based on the mode. Up An integer output port that will report the result of checking the state of the   up controller input based on the mode. Down An integer output port that will report the result of checking the state of the   down controller input based on the mode. Jump/Fire An integer output port that will report the result of checking the state of the   jump/fire controller input based on the mode."},{"location":"logic/nodes/controller/#parameters","title":"Parameters","text":"Left A constant integer value that will be output on the Left port if the input   check matches the mode for the left input. Right A constant integer value that will be output on the Right port if the input   check matches the mode for the right input. Up A constant integer value that will be output on the Up port if the input   check matches the mode for the up input. Down A constant integer value that will be output on the Down port if the input  check matches the mode for the down input. Jump/Fire A constant integer value that will be output on the Jump/Fire port if the   input check matches the mode for the jump/fire input. Mode Define the mode of operation between Pressed, Released, Just Pressed and   Just Released. See the description of the node operation for an explanation   of the difference between the modes."},{"location":"logic/nodes/direction/","title":"Direction","text":""},{"location":"logic/nodes/direction/#description","title":"Description","text":"<p> The Direction Node is used to convert the typical four directional movement input into a single value representing the primary direction of movement. This is useful for things like switching sprite animation on Objects to show the correct animation for the movement. If the input suggests a diagonal movement, the output will be a single value representing the \"dominant\" axis as defined by the Vertical Priority parameter, if this is checked, then up/down will be chosen over left/right if diagonal movement is indicated, if it is not checked, left/right will get priority.</p> <p>Note: unlike other nodes with port/parameter pairs, in this node the direction rows are not port or parameter, both are required. The port is the input, usually from a Controller node, while the parameter represents the output value that will be used if that direction is determined to be the dominant direction. In the example here, if only the right controller is non-0, the Direction value output will be 2.</p> <p></p>"},{"location":"logic/nodes/direction/#ports","title":"Ports","text":"Left An integer input port providing the input value for the left direction, any   non-0 value will be considered movement in that direction.  Right An integer input port providing the input value for the right direction, any   non-0 value will be considered movement in that direction. Up An integer input port providing the input value for the up direction, any   non-0 value will be considered movement in that direction. Down An integer input port providing the input value for the down direction, any   non-0 value will be considered movement in that direction. Direction An integer output port, one of the four direction parameter values will be   output on this port depending on the input data and the Vertical Priority   parameter."},{"location":"logic/nodes/direction/#parameters","title":"Parameters","text":"Vertical Priority A boolean value indicating which axis to give priority to if diagonal   movement is indicated. If checked, up/down will get priority, otherwise   left/right will. Left A constant integer value that will be output on the Output port if the    inputs indicate movement left. Right A constant integer value that will be output on the Output port if the    inputs indicate movement right. Up A constant integer value that will be output on the Output port if the    inputs indicate movement up. Down A constant integer value that will be output on the Output port if the    inputs indicate movement down."},{"location":"logic/nodes/get_global_object/","title":"Get Global Object","text":""},{"location":"logic/nodes/get_global_object/#description","title":"Description","text":"<p> The Get Global Object Node is used to get an Object Reference to a global object for use further down the graph in other nodes that accept a Ref input. This allows you to directly affect global objects, moving them, etc.</p> <p></p>"},{"location":"logic/nodes/get_global_object/#ports","title":"Ports","text":"Ref An Object Ref output port that will provide the reference to the requested   global object."},{"location":"logic/nodes/get_global_object/#parameters","title":"Parameters","text":"Object A dropdown selector that will list all the currently available global objects.   The value selected will dictate which Ref is returned."},{"location":"logic/nodes/get_room_object/","title":"Get Room Object","text":""},{"location":"logic/nodes/get_room_object/#description","title":"Description","text":"<p>  The Get Room Object Node is used to get an Object  Reference to an object in a room for  use further down the graph in other nodes that accept a Ref input. This  allows you to directly affect room objects, moving them, etc.</p> <p></p>"},{"location":"logic/nodes/get_room_object/#ports","title":"Ports","text":"Ref An Object Ref output port that will provide the reference to the requested   global object."},{"location":"logic/nodes/get_room_object/#parameters","title":"Parameters","text":"Room A dropdown selector that will list all the currently available rooms.   When a room is selected, the contents of the Object selector will update   to list the object references in that room. Object A dropdown selector that will list all the currently available objects in the   selected room. The value selected will dictate which Ref is returned."},{"location":"logic/nodes/get_variable/","title":"Get","text":""},{"location":"logic/nodes/get_variable/#description","title":"Description","text":"<p> The Get Node is used to get the integer value of a variable on whatever the current logic graph is running, i.e. a Screen, a Room or an Object.</p> <p>It's important to understand that the value being returned is the value for the chosen variable in the Object Reference that is running the logic code, each reference has it's own version of the variables, so accessing a variable on one reference for a particular object type will not necessarily return the same value as for another reference, they are independent.</p> <p></p>"},{"location":"logic/nodes/get_variable/#ports","title":"Ports","text":"Output An integer output port that will provide the value of the chosen variable."},{"location":"logic/nodes/get_variable/#parameters","title":"Parameters","text":"Variable A dropdown listing the defined variables associated with the current logic graph."},{"location":"logic/nodes/global_variable/","title":"Global Variable","text":""},{"location":"logic/nodes/global_variable/#description","title":"Description","text":"<p> The Global Variable Node is used to get the integer value of a variable on the global Logic.</p> <p></p>"},{"location":"logic/nodes/global_variable/#ports","title":"Ports","text":"Output An integer output port that will provide the value of the chosen variable."},{"location":"logic/nodes/global_variable/#parameters","title":"Parameters","text":"Variable A dropdown listing the defined variables associated with the global logic graph."},{"location":"logic/nodes/increment/","title":"Increment","text":""},{"location":"logic/nodes/increment/#description","title":"Description","text":"<p> The Increment Node is a simple way to modify the value of a variable on the current logic graph in one operation, avoiding the need for a Get, Math and Set sequence.</p> <p></p>"},{"location":"logic/nodes/increment/#ports","title":"Ports","text":"Flow In In order for this node to perform its operation, it must be connected into an   active flow using this input port. The flow will ultimately originate at a   Trigger node but can come from the Flow Out port of any other flow   node. Flow Out A node connected to the Flow Out port will be executed in sequence   following the completion of this node's operation. By An integer input port used to provide the amount that the variable will be    changed by, this can be positive or negative."},{"location":"logic/nodes/increment/#parameters","title":"Parameters","text":"By A constant integer amount that the variable will be changed by, used when the    By port is not connected. Variable A dropdown listing the defined variables associated with the current logic graph."},{"location":"logic/nodes/initialise/","title":"Initialise","text":""},{"location":"logic/nodes/initialise/#description","title":"Description","text":"<p> The Initialise Node is a specific type of Node called a Trigger. A trigger Node is an entrypoint into a flow in the Kwyll logic. The Initialise trigger will run the flow that follows on from it's Flow Out port only once at the start of the game.</p> <p></p>"},{"location":"logic/nodes/initialise/#ports","title":"Ports","text":"Flow Out As with all trigger nodes, an Initialse Node has only a single flow port   on the output side. There is no input flow to a trigger node as it is   the origin of a flow."},{"location":"logic/nodes/instance_data/","title":"Instance Data","text":""},{"location":"logic/nodes/instance_data/#description","title":"Description","text":"<p> The Instance Data Node provides useful information about the current Object Reference that the logic graph is running on. This is information that is unique to each reference of the object type, much like variables, but for accessing common data that all object references have.</p> <p>Note: the position data is returned in the appropriate coordinate system for the object being referenced. A global or dynamic object will return coordinates in \"map\" space, a room object will return coordinates in the local space of the room.</p> <p></p>"},{"location":"logic/nodes/instance_data/#ports","title":"Ports","text":"Ref An Object Reference input port that can provide an object that will be used   to lookup the instance data. If this is not connected and the logic is on   an Object, the current object   will be used instead. If the logic is not on an object, 0 will be returned   on all output ports. Start X The initial X position of the object, this is constant, and used to reset the    object's position at the start of the game. Start Y The initial Y position of the object, this is constant, and used to reset the    object's position at the start of the game. X The current X position of the object, this is the live position of the object   as set by any Move Object nodes, or other nodes that can   modify an object's position.  Y The current Y position of the object, this is the live position of the object   as set by any Move Object nodes, or other nodes that can   modify an object's position."},{"location":"logic/nodes/integer_compare/","title":"Integer Compare","text":""},{"location":"logic/nodes/integer_constant/","title":"Integer Constant","text":""},{"location":"logic/nodes/is_on_screen/","title":"Is On Screen?","text":""},{"location":"logic/nodes/is_type/","title":"Is Type?","text":""},{"location":"logic/nodes/kill_object/","title":"Kill Object","text":""},{"location":"logic/nodes/math/","title":"Math","text":""},{"location":"logic/nodes/modify_tiles/","title":"Modify Tiles","text":""},{"location":"logic/nodes/move_object/","title":"Move Object","text":""},{"location":"logic/nodes/object_variable/","title":"Object Variable","text":""},{"location":"logic/nodes/or/","title":"Or","text":""},{"location":"logic/nodes/or/#description","title":"Description","text":"<p> The Or Node takes two inputs of type integer and compares them with 0. If either or both are not 0, the output will be 1, if both are 0, the output will be 0. </p> <p>This is useful to combine checks, in particular with the Integer Compare nodes.</p>"},{"location":"logic/nodes/or/#ports","title":"Ports","text":""},{"location":"logic/nodes/or/#a-and-b","title":"A and B","text":"<p>The two input values, they must be linked for the node to be operational and can only be connected to sources that provide an integer value, such as Get.</p>"},{"location":"logic/nodes/or/#out","title":"Out","text":"<p>The output of the node, will be either 1 or 0 depending on the result of the compare.</p>"},{"location":"logic/nodes/paste_brush/","title":"Paste Brush","text":""},{"location":"logic/nodes/random/","title":"Random","text":""},{"location":"logic/nodes/reset_game/","title":"Reset Game","text":""},{"location":"logic/nodes/select/","title":"Select","text":""},{"location":"logic/nodes/set_global_variable/","title":"Set Global Variable","text":""},{"location":"logic/nodes/set_instrument/","title":"Set Instrument","text":""},{"location":"logic/nodes/set_object_variable/","title":"Set Object Variable","text":""},{"location":"logic/nodes/set_variable/","title":"Set","text":""},{"location":"logic/nodes/set_variable/#description","title":"Description","text":"<p> The Set Node is used to set the integer value of a variable on whatever the current logic graph is running, i.e. a Screen, a Room or an Object.</p> <p>It's important to understand that the value being modified is the value for the chosen variable in the Object Reference that is running the logic code, each reference has it's own version of the variables, so changing a variable on one reference for a particular object type will not affect the value on other references, they are independent.</p> <p></p>"},{"location":"logic/nodes/set_variable/#ports","title":"Ports","text":"Flow In In order for this node to perform its operation, it must be connected into an   active flow using this input port. The flow will ultimately originate at a   Trigger node but can come from the Flow Out port of any other flow   node. Flow Out A node connected to the Flow Out port will be executed in sequence   following the completion of this node's operation. Value An integer input port used to provide the value that will be applied to the   chosen variable."},{"location":"logic/nodes/set_variable/#parameters","title":"Parameters","text":"Value A constant integer value to assign to the chosen variable. If the port is    connected to another node, this option will become unavailable, the node   will use the value provided on the input port. Variable A dropdown listing the defined variables associated with the current logic graph."},{"location":"logic/nodes/spawn_object/","title":"Spawn Object","text":""},{"location":"logic/nodes/sprite_animation/","title":"Sprite Animation","text":""},{"location":"logic/nodes/subgraph/","title":"Subgraphs","text":""},{"location":"logic/nodes/switch_screen/","title":"Switch Screen","text":""},{"location":"logic/nodes/timeline_animation/","title":"Timeline Animation","text":""},{"location":"logic/nodes/transport_object/","title":"Transport Object","text":""},{"location":"logic/nodes/transport_to_marker/","title":"Transport To Marker","text":""},{"location":"logic/nodes/z80_out/","title":"Z80 Out","text":""}]}